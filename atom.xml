<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Legendgod&#39;s Blog</title>
  
  <subtitle>终幕</subtitle>
  <link href="https://legendgod.ml/atom.xml" rel="self"/>
  
  <link href="https://legendgod.ml/"/>
  <updated>2022-11-11T11:18:54.385Z</updated>
  <id>https://legendgod.ml/</id>
  
  <author>
    <name>legendgoddes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://legendgod.ml/2022/11/11/test/"/>
    <id>https://legendgod.ml/2022/11/11/test/</id>
    <published>2022-11-11T07:46:20.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;test&lt;/p&gt;
</summary>
      
    
    
    
    <category term="THUPC题解" scheme="https://legendgod.ml/categories/THUPC%E9%A2%98%E8%A7%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>关于成立拜上帝教的主张</title>
    <link href="https://legendgod.ml/2022/06/25/my_for_the_god_and_fate/"/>
    <id>https://legendgod.ml/2022/06/25/my_for_the_god_and_fate/</id>
    <published>2022-06-25T09:31:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<h2><center>拜上帝教</center></h2><p>我不知道和洪秀全那个家伙拜的是不是一个上帝，可能只是碰巧名字一样罢了。</p><p>无论我们的主是不是一样的，究其根本主的信徒在历史长河中有着无数的星星点点，一个点便是一代星火。</p><p>都说人在历史长河中连一滴水都算不上，主却不然，他（她）的思想便是这篇汪洋大海。</p><p>就算主的思想是一滴水，但是这滴水在大海中便会均匀扩散最终这篇大海就是主的本身。</p><hr><h2><center>主</center></h2><p>主是全知全能的，一半来说我们称主为命运或者上帝。</p><h2><center>教会礼制</center></h2><p>没有什么礼制，我们崇尚自由，但是唯独不能改变的就是信念。</p><p>你可以每天祈祷，甚至一个月祈祷一次。但是当别人提起你的信仰的时候你需要毫不犹豫地说出来，我信<strong>主</strong>。</p><p>我是教主：罗斯。</p><h2><center>主</center></h2><p>主会不断给予我们力量，能力，智慧以至于一切。</p><p>无时无刻相信主，危难的时候相信主，才会得到救赎。</p><h2><center>初衷</center></h2><p>马上要学考了，估计不能过了。</p><p>一点动力都没有，要是有 $2A \sim 4A$ 就满足，不然自杀或者听凭上帝惩治。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;center&gt;拜上帝教&lt;/center&gt;&lt;/h2&gt;

&lt;p&gt;我不知道和洪秀全那个家伙拜的是不是一个上帝，可能只是碰巧名字一样罢了。&lt;/p&gt;
&lt;p&gt;无论我们的主是不是一样的，究其根本主的信徒在历史长河中有着无数的星星点点，一个点便是一代星火。&lt;/p&gt;
&lt;p&gt;都说人在历史长</summary>
      
    
    
    
    <category term="通知" scheme="https://legendgod.ml/categories/%E9%80%9A%E7%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>关于学信息的一些想法</title>
    <link href="https://legendgod.ml/2022/06/17/thinking-1/"/>
    <id>https://legendgod.ml/2022/06/17/thinking-1/</id>
    <published>2022-06-17T05:37:00.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于学信息的一些想法"><a href="#关于学信息的一些想法" class="headerlink" title="关于学信息的一些想法"></a>关于学信息的一些想法</h2><p>$\texttt{tnnd}$ 不知道是不是已经退役的缘故，现在有一些人就是来问我关于学信息的一些问题，我也就不一个一个回答了感觉很多部分是相同的，我就放到一篇博客里面了。</p><ol><li>学信息有用吗？</li></ol><blockquote><p>看程度，如果您水平很强那显然可以保送，但是对于大多数人来说，还是只有 $\tt NOIP\ 1&#x3D;$ 的水平。</p><p>这个据说是可以羟基直接入围。</p></blockquote><ol start="2"><li>我<strong>六年级</strong>开始学信息来得及吗？</li></ol><blockquote><p>首先需要明确的是学信息的时间是因人而异的，也不一定是越早越好。</p><p>当然如果之后想通过信息这条路的话，肯定是早点学信息来得好。</p><p>其次是否来得及还需要考虑自身的天赋和努力，但是这个时候开始学习时肯定不晚的。</p></blockquote><ol start="3"><li>我高中被拉去信息社团，有必要停课吗？</li></ol><blockquote><p>如果您是天赋选手那么肯定停课，对于大部分普通的选手来说，停课是没有必要的。</p></blockquote><ol start="4"><li>信息竞赛是不是就是玩电脑啊，我们家打电脑可厉害了，你来看看有没有天赋。</li></ol><blockquote><p>$\cdots$</p></blockquote><ol start="5"><li>听说机房里面会有人偷偷打游戏？</li></ol><blockquote><p>废话，你看文化课教室也有人上课睡觉。</p></blockquote><ol start="6"><li>机房的氛围很重要吗？</li></ol><blockquote><p>其实不是很重要，就算有人天天划水，你自己该学学，该问问就好了。</p><p>主要怕没有能给你解答问题的人。</p></blockquote><ol start="7"><li>需要经常到别的学校集训吗？</li></ol><blockquote><p>我没有集训过，我不清楚。</p></blockquote><ol start="8"><li>你对于学信息后悔吗？</li></ol><blockquote><p>反正选择了也没有什么后悔的，如果有机会我会把 ZLD 的狗头打爆。</p></blockquote><ol start="9"><li>作为全天停课的选手，学考紧张吗？</li></ol><blockquote><ul><li>作为生理意义上来说，不需要紧张，因为摆烂了。</li><li>如果作为精神意义上来说，挺紧张的，很多东西都没有学过。</li></ul></blockquote><ol start="10"><li>你好菜呀！</li></ol><blockquote><p>哦，你才知道吗？</p></blockquote><hr><p>我毕竟是初一接触，初三才开始下狠心学习的。</p><p>现在高一下册，如果除去那些因为完全不会浪费的半年时间，实际也才学习了 $1$ 年多一点，时间不是很多。</p><p>我的天赋是平均偏下的，这点在学习算法的速度上可以体现出来，$1$ 年的时间最多从普及 $-$ 走到预备省选罢了。</p><p>说实话我是比较幸运的，我们同行是有 $10$ 人，其他的所有人都是小学就开始学习了，我能留到最后属实是一种好运。</p><p>当然有问题可以直接提问，我可能会加入进去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于学信息的一些想法&quot;&gt;&lt;a href=&quot;#关于学信息的一些想法&quot; class=&quot;headerlink&quot; title=&quot;关于学信息的一些想法&quot;&gt;&lt;/a&gt;关于学信息的一些想法&lt;/h2&gt;&lt;p&gt;$\texttt{tnnd}$ 不知道是不是已经退役的缘故，现在有一些人就是</summary>
      
    
    
    
    <category term="随笔" scheme="https://legendgod.ml/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>UOJ 269 [清华集训2016] 如何优雅地求和 题解</title>
    <link href="https://legendgod.ml/2022/06/13/uoj-solution-269/"/>
    <id>https://legendgod.ml/2022/06/13/uoj-solution-269/</id>
    <published>2022-06-13T11:55:00.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UOJ-269-清华集训2016-如何优雅地求和"><a href="#UOJ-269-清华集训2016-如何优雅地求和" class="headerlink" title="UOJ 269 [清华集训2016] 如何优雅地求和"></a><a href="https://uoj.ac/problem/269">UOJ 269 [清华集训2016] 如何优雅地求和</a></h2><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a><strong>题意：</strong></h4><p>给定一个函数 $f(x)$，求出 $Q &#x3D; \sum_{k &#x3D; 0} ^ n f(k) \binom{n}{k} x^k (1 - x)^{n - k}$。</p><p>给定了 $f, n, x$。</p><hr><p>可以发现给定了 $x$ 之后后面的两项可以看成常数但是又不能完全看成常数，但是可以 $O(1)$ 计算的，不妨设系数为 $c_i$。</p><p>那么就是求 $Q &#x3D; \sum_{k &#x3D; 0} ^ n f(k) \binom{n}{k} c_i$。</p><p>考虑拆开来看:</p><p>$$<br>\begin{aligned}<br>&amp;\sum_{k &#x3D; 0} ^ n \sum_{j &#x3D; 0} ^ m k^j \binom{n}{k} c_k \\<br>&#x3D;&amp; \sum_{k  &#x3D;0}^ n c_k \binom{n}{k} \sum_{j &#x3D; 0} ^ m k^j \\<br>\end{aligned}<br>$$</p><p>考虑后面的部分怎么操作：</p><p>显然后面部分为 $\frac{k^{m + 1} - 1}{k - 1}$。</p><p>可以是很遗憾的一点就是 $n$ 巨大，只能通过一些部分分。</p><p>发现这个 $m$ 好像可以操作一下，考虑提出 $m$。</p><p>如果不考虑 $k^j$ 的话可以直接二项式定理。</p><p>考虑拆掉 $k$。</p><p>$$<br>\begin{aligned}<br>&amp; \sum_{j &#x3D; 0} ^ m \sum_{k &#x3D; 0} ^ n k^j \binom{n}{k} x^k (1 - x) ^ {n - k} \\<br>&#x3D;&amp; \sum_{j &#x3D; 0} ^ m \sum_{k &#x3D; 0} ^ n \binom{n}{k} x^k (1 -x) ^{n - k} \sum_{z &#x3D; 0} ^ j<br>\begin{Bmatrix} j \ z\end{Bmatrix}<br>k^{\underline{z}} \\<br>&#x3D;&amp; \sum_{j &#x3D; 0} ^ m \sum_{z &#x3D; 0} ^ j<br>\begin{Bmatrix} j \ z\end{Bmatrix} n^{\underline{z}} x^z \sum_{k &#x3D; 0} ^ n x^{k - z} (1 -x) ^{n - k}  \binom{n - z}{k - z} \\<br>&#x3D;&amp; \sum_{j &#x3D; 0} ^ m \sum_{z &#x3D; 0} ^ j<br>\begin{Bmatrix} j \ z\end{Bmatrix} n^{\underline{z}} x^z \sum_{k &#x3D; 0} ^ {n - z} x^{k} (1 -x) ^{n - k - z}  \binom{n - z}{k} \\<br>&#x3D;&amp; \sum_{j &#x3D; 0} ^ m a_j \sum_{z &#x3D; 0} ^ j x^z n^{\underline{z}}<br>\begin{Bmatrix} j \ z\end{Bmatrix}<br>\end{aligned}<br>$$</p><p>考虑将右边的东西展开：</p><p>$$<br>\begin{aligned}<br>&amp; \sum_{j  &#x3D;0} ^ m a_i \sum_{z &#x3D; 0} ^ j \binom{n}{z} x^z \sum_{s &#x3D; 0} ^ z<br>(-1)^{z - s} \binom{z}{s} s^j  \\<br>&#x3D;&amp; \sum_{z &#x3D; 0} ^ m \binom{n}{z} x^z \sum_{s &#x3D; 0} ^ z (-1) ^ {z - s} \binom{z}{s} \sum_{j &#x3D; z} ^ m a_j s^j \end{aligned}<br>$$</p><p>$\tt Trick:$ 对于斯特林数的公式当 $i &lt; j$ 的时候也适用，所以后面可以直接变成 $j &#x3D; 0$，那么后面就是点值了。</p><p>直接进行操作即可。</p><p>发现前面的东西就是一个卷积，直接求出来即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a, b, c) for(int a = (b); a &lt;= (c); ++ a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uFor(a, b, c) for(int a = (b); a &lt; (c); ++ a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pfor(a, b, c) for(int a = (b); a &lt;= (c); ++ a, puts(<span class="meta-string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forp(a, b, c) for(int a = (b); a &lt;= (c); ++ a, (a == (c + 1) ? puts(<span class="meta-string">&quot;&quot;</span>) : 0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dor(a, b, c) for(int a = (b); a &gt;= (c); -- a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uDor(a, b, c) for(int a = (b); a &gt; (c); -- a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pdor(a, b, c) for(int a = (b); a &gt;= (c); -- a, puts(<span class="meta-string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dorp(a, b, c) for(int a = (b); a &gt;= (c); -- a, (a == (c - 1) ? puts(<span class="meta-string">&quot;&quot;</span>) : 0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Por(a) printf(<span class="meta-string">&quot;%s = %d\n&quot;</span>, #a, a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rpor(a, b) printf(<span class="meta-string">&quot;%s, %s = %d, %d\n&quot;</span>, #a, #b, a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tor(a, b) printf(<span class="meta-string">&quot;%s = %d : %d\n&quot;</span>, #a, a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sbg puts(<span class="meta-string">&quot;\nBegin&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sed puts(<span class="meta-string">&quot;End\n&quot;</span>)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>, G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, rev[maxn], lim, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>, len = <span class="number">0</span>; lim &lt;= x; lim &lt;&lt;= <span class="number">1</span>, ++ len);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(mi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fac[maxn], finv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">1</span>, x) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    finv[x] = <span class="built_in">ksm</span>(fac[x], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Dor</span>(i, x - <span class="number">1</span>, <span class="number">0</span>) finv[i] = <span class="number">1ll</span> * finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> op = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim - <span class="number">1</span>) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, c = (mid &lt;&lt; <span class="number">1</span>); j &lt; lim; j += c) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>, wn = <span class="built_in">ksm</span>(op == <span class="number">1</span> ? G : invG, (mod - <span class="number">1</span>) / c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++ k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = A[j + k], y = <span class="number">1ll</span> * A[j + k + mid] * w % mod;</span><br><span class="line">                A[j + k] = (x + y) % mod;</span><br><span class="line">                A[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">                w = <span class="number">1ll</span> * w * wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">ksm</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">For</span>(i, <span class="number">0</span>, lim - <span class="number">1</span>) A[i] = <span class="number">1ll</span> * A[i] * z % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, x;</span><br><span class="line">    <span class="built_in">r1</span>(n, m, x);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) <span class="built_in">r1</span>(a[i]);</span><br><span class="line">    <span class="built_in">init</span>(m);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sx[maxn], sy[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(sx, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sx)), <span class="built_in">memset</span>(sy, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sy));</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        sx[i] = <span class="number">1ll</span> * a[i] * finv[i] % mod;</span><br><span class="line">        sy[i] = (i &amp; <span class="number">1</span> ? mod - finv[i] : finv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getrev</span>(m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(sx), <span class="built_in">NTT</span>(sy);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, lim - <span class="number">1</span>) sx[i] = <span class="number">1ll</span> * sx[i] * sy[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(sx, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) sx[i] = <span class="number">1ll</span> * sx[i] * fac[i] % mod;</span><br><span class="line"><span class="comment">//    Forp(i, 0, m) printf(&quot;%d &quot;, sx[i]);</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sp</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">pwx</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, <span class="built_in">min</span>(n, m)) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1ll</span> * sp * pwx % mod * sx[i] % mod) % mod;</span><br><span class="line">        sp = <span class="number">1ll</span> * sp * (n - i) % mod * <span class="built_in">ksm</span>(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        pwx = <span class="number">1ll</span> * pwx * x % mod;</span><br><span class="line"><span class="comment">//        printf(&quot;ans = %d\n&quot;, ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>其实这题还有一种解法，我们考虑最后的式子，如果你和我一样没有学过转下降幂那么就一起看看：</p><p>$f(x)$ 的下降幂表示。</p><p>考虑多项式 $g(x)$ 为其下降幂表示：<br>$$<br>\sum_{i &#x3D; 0} ^ n a_i \sum_{j &#x3D; 0} ^ i \begin{Bmatrix}i \ j\end{Bmatrix}  x^{\underline{j}}<br>$$<br>交换之后就是 $\sum_{j &#x3D; 0} ^ n x^{\underline{j}}\sum_{i &#x3D; j} ^ n a_i \begin{Bmatrix} i \ j  \end{Bmatrix} $。</p><blockquote><p>对于形式要敏感。</p></blockquote><p>所以说人话就是 $f(x)$ 的某个下降幂表示。</p><p>那么我们对于 $f(x)$ 的点值表示如何快速求出其下降幂的表示。</p><p>显然最终的答案就是： $\sum_{z &#x3D; 0} ^ m x^z n^{\underline{z}} g_z$。</p><p>直接的想法就是拉格朗日差值，但是直接暴力差值貌似是不行的。</p><p>考虑其点值的 $\tt egf$。<br>$$<br>\begin{aligned}<br>&amp; \sum_{i &#x3D; 0} ^ m \frac{f(i)}{i!} x^i \\<br>&#x3D;&amp; \sum_{i &#x3D; 0} ^ m \frac{x^i}{i!} \sum_{j &#x3D; 0} ^ m i^{\underline{j}} g_j \\<br>&#x3D;&amp; \sum_{j &#x3D; 0} ^ m g_j \sum_{i &#x3D; 0} ^ m \frac{x^i}{(i - j)!}<br>\end{aligned}<br>$$<br>显然这个东西就是 $G$ 和 $e^x$ 的卷积，我们有 $G e^x &#x3D; F$ 所以 $G &#x3D; F e^{-x}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a, b, c) for(int a = (b); a &lt;= (c); ++ a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uFor(a, b, c) for(int a = (b); a &lt; (c); ++ a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pfor(a, b, c) for(int a = (b); a &lt;= (c); ++ a, puts(<span class="meta-string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forp(a, b, c) for(int a = (b); a &lt;= (c); ++ a, (a == (c + 1) ? puts(<span class="meta-string">&quot;&quot;</span>) : 0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dor(a, b, c) for(int a = (b); a &gt;= (c); -- a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uDor(a, b, c) for(int a = (b); a &gt; (c); -- a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pdor(a, b, c) for(int a = (b); a &gt;= (c); -- a, puts(<span class="meta-string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dorp(a, b, c) for(int a = (b); a &gt;= (c); -- a, (a == (c - 1) ? puts(<span class="meta-string">&quot;&quot;</span>) : 0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Por(a) printf(<span class="meta-string">&quot;%s = %d\n&quot;</span>, #a, a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rpor(a, b) printf(<span class="meta-string">&quot;%s, %s = %d, %d\n&quot;</span>, #a, #b, a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tor(a, b) printf(<span class="meta-string">&quot;%s = %d : %d\n&quot;</span>, #a, a, b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sbg puts(<span class="meta-string">&quot;\nBegin&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sed puts(<span class="meta-string">&quot;End\n&quot;</span>)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>, G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, rev[maxn], lim, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>, len = <span class="number">0</span>; lim &lt;= x; lim &lt;&lt;= <span class="number">1</span>, ++ len);</span><br><span class="line">    <span class="built_in">uFor</span>(i, <span class="number">0</span>, lim) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(mi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> op = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">uFor</span>(i, <span class="number">0</span>, lim) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, c = (mid &lt;&lt; <span class="number">1</span>); j &lt; lim; j += c) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>, wn = <span class="built_in">ksm</span>(op == <span class="number">1</span> ? G : invG, (mod - <span class="number">1</span>) / c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++ k, w = <span class="number">1ll</span> * w * wn % mod) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = A[j + k], y = <span class="number">1ll</span> * A[j + k + mid] * w % mod;</span><br><span class="line">                A[j + k] = (x + y) % mod;</span><br><span class="line">                A[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">ksm</span>(lim, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">uFor</span>(i, <span class="number">0</span>, lim) A[i] = <span class="number">1ll</span> * A[i] * z % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fac[maxn], finv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">1</span>, x) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    finv[x] = <span class="built_in">ksm</span>(fac[x], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Dor</span>(i, x - <span class="number">1</span>, <span class="number">0</span>) finv[i] = <span class="number">1ll</span> * finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b || a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[a] * finv[b] % mod * finv[a - b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> Calc = [&amp;] () -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> pw[maxn], pw1[maxn];</span><br><span class="line">        <span class="built_in">memset</span>(pw, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pw)), <span class="built_in">memset</span>(pw1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pw1));</span><br><span class="line">        pw[<span class="number">0</span>] = pw1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">For</span>(i, <span class="number">1</span>, n) pw[i] = <span class="number">1ll</span> * pw[i - <span class="number">1</span>] * x % mod;</span><br><span class="line">        <span class="built_in">For</span>(i, <span class="number">1</span>, n) pw1[i] = <span class="number">1ll</span> * pw1[i - <span class="number">1</span>] * (<span class="number">1</span> - x + mod) % mod;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">For</span>(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">            ans = (ans + <span class="number">1ll</span> * a[i] * <span class="built_in">C</span>(n, i) % mod * pw[i] % mod * pw1[n - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">r1</span>(n, m, x);</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) <span class="built_in">r1</span>(a[i]);</span><br><span class="line">    <span class="built_in">init</span>(m);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= m) <span class="keyword">return</span> <span class="built_in">Calc</span>(), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[maxn], B[maxn];</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(A)), <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(B));</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        A[i] = (i &amp; <span class="number">1</span> ? mod - finv[i] : finv[i]);</span><br><span class="line">        B[i] = <span class="number">1ll</span> * a[i] * finv[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getrev</span>(m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">NTT</span>(A), <span class="built_in">NTT</span>(B);</span><br><span class="line">    <span class="built_in">uFor</span>(i, <span class="number">0</span>, lim) A[i] = <span class="number">1ll</span> * A[i] * B[i] % mod;</span><br><span class="line"><span class="comment">//    uFor(i, 0, lim) Tor(i, A[i]);</span></span><br><span class="line">    <span class="built_in">NTT</span>(A, <span class="number">-1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pw</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="built_in">For</span>(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        ans = (ans + <span class="number">1ll</span> * pw * A[i]) % mod;</span><br><span class="line">        pw = <span class="number">1ll</span> * pw * x % mod * (n - i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UOJ-269-清华集训2016-如何优雅地求和&quot;&gt;&lt;a href=&quot;#UOJ-269-清华集训2016-如何优雅地求和&quot; class=&quot;headerlink&quot; title=&quot;UOJ 269 [清华集训2016] 如何优雅地求和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="UOJ题解" scheme="https://legendgod.ml/categories/UOJ%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="生成函数" scheme="https://legendgod.ml/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="斯特林数" scheme="https://legendgod.ml/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>#593. 新年的军队 题解</title>
    <link href="https://legendgod.ml/2022/06/01/uoj-solution-593/"/>
    <id>https://legendgod.ml/2022/06/01/uoj-solution-593/</id>
    <published>2022-06-01T23:50:00.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="593-新年的军队"><a href="#593-新年的军队" class="headerlink" title="#593. 新年的军队"></a><a href="https://uoj.ac/problem/593">#593. 新年的军队</a></h2><p>属实是一道神仙题，估计是去年这个时候听说了这道题，最近把这个坑填了。</p><p>给后面要来写的人提个醒，这个题其实没有想象地那么恐怖，代码其实也不复杂，只是推导十分困难。</p><p>我说我这篇是全网最详细的不过分吧。</p><hr><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>首先我们熟悉一下题目，本质上就是考虑所有的排列 $p$，一个合法的排列有 $m$ 个 $p_i &gt; p_{i + 1}$，求 $\forall l, p_k &#x3D; l$ 的排列 $p$ 的方案数。</p><p>暴力直接全排列即可。</p><hr><h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><p>显然是人都会全排列，我们考虑点别的。可以发现这个 <code>恰好 m 个下降</code> 就是欧拉数。</p><p>我们现在的困难就是如何对应每个 $p_k &#x3D; l$，并且求出方案数。</p><p>考虑使用科技解决这个问题，我们先简化一下如果只需要求一个固定的 $l$。</p><p>$Q1:$ 看到很大的数据范围说明很难使用 $\tt Dp$ 来解决问题，况且欧拉数 $\tt Dp$ 是 $O(n^2)$ 的，已经难以推广。</p><p>考虑一个经典转化，单点方案数其实可以等价于概率乘上总方案，我们已知总方案我们不妨来计算概率。</p><p>$Q2:$ 很显然如果直接考虑所有排列的话我们不一定满足条件，我们不妨只考虑选取的数之后通过别的方式来计算出合法的排列个数。</p><blockquote><p>显然这个合法的排列个数就是答案。这就意味着反演。</p></blockquote><p>考虑使用概率密度函数：</p><blockquote><p>我们考虑一个点在 $4 \times \frac{1}{4}$ 的长方形内区间 $[1, 2]$ 的分布概率，就是函数在 $[1, 2]$ 区间的积分。</p><p>这个 $\frac{1}{4}$ 其实就是个类似概率密度函数的东西。它用来描述连续型随机变量的输出值。我们想要知道它落在某个区间上的概率，只需要在这个区间上对概率密度函数作积分即可。</p></blockquote><p>这样转化的好处在于我们可以很轻松地添加一个数。</p><p>$Q3:$ 我们选择数的方案数事实上是会被之前选择的某些数限制了，我们将其放到实数上这样可以解除这样的限制。</p><p>有 $n$ 个数，每个数的取值是实数 $[0, 1]$，满足有 $m$ 个下降。</p><p>建立模型来表示值 $x$ 落在某个区间的概率。</p><p>设特定位置为 $k$ 的总方案数是 $\alpha_k$ 我们可以得出转化关系。</p><p>这样考虑位置 $j$ 对概率密度函数的贡献就是 $\dfrac{\alpha_j }{(j - 1)!(n - j)!}\times x^{j - 1}(1 - x)^{n-  j}$。</p><blockquote><p>考虑任何一个合法的排列，我们将其分成 $&lt; x$ 和 $&gt; x$ 两部分，因为没有数相同所以 $&lt; x$ 占据的位置是 $(j - 1)!$ 排列中的一种，$&gt; x$ 同理。</p></blockquote><p>$$<br>\sum_{j &#x3D; 0} ^ {n - 1} \alpha_j\frac{x^j(1 - x)^{n - 1 - j}}{j!(n - 1 - j)!} &#x3D; \sum_{j &#x3D; 0} ^ {n - 1} f_jx^j &#x3D; f(x)<br>$$<br>后面的部分表示的仅仅是上述的生成函数，考虑如果已知生成函数如何求出 $\alpha$。</p><p>考虑进行换元，我们不需要关注左边的常数，提出来 $x^{n - 1}$ 可以得到 $(\frac{x}{1 - x})^j$ 换元为 $y^j$。</p><p>之后考虑有 $\frac{x}{1 - x} &#x3D; y$ 那么有 $x &#x3D; \frac{y}{1 + y}$ 带入右边得到 $(\frac{y}{1 + y})^j$ 之后将左边的 $(1 - x)^{n - 1}$ 放到右边可以得到 $(\frac{1}{1 + y})^{1 - n}$。</p><p>我们重新写一下这个式子：<br>$$<br>\sum_{j &#x3D; 0}^{n - 1}\alpha_j \frac{y^j}{j!(n - 1 - j)!} &#x3D; \sum_{j &#x3D; 0} ^{n - 1} f_j y^j (1 + y)^{n - 1 - j}<br>$$<br>之后将 $y$ 看成 $x$ 即可。</p><p>右边的形式不是很好，不好卷积，考虑展开一下：<br>$$<br>\begin{aligned}<br>\sum_{j &#x3D; 0} ^ {n - 1} f_j x^j(1 + x) ^{n - 1 - j} &amp;&#x3D; \sum_{j &#x3D; 0} ^ j f_j x^j \sum_{k &#x3D; 0} ^ {n - j - 1} \binom{n - j - 1}{k} x^k \\<br>&amp;&#x3D; \sum_{j &#x3D; 0} ^ j f_j x^j \sum_{k &#x3D; 0} ^ {n - j - 1} \frac{(n - j - 1)!}{k!(n - j - k - 1)!} x^k \\<br>&amp;&#x3D; \sum_{j &#x3D; 0} ^ j f_j (n - j - 1)! x^j \sum_{k &#x3D; 0} ^ {n - j - 1} \frac{1}{k!(n - j - k - 1)!} x^k \\<br>&amp;&#x3D; \sum_{j &#x3D; 0} ^ j x^j \times \frac{1}{(n - j - 1)!}\sum_{a + b &#x3D; j} f_a(n - a -1)! \times \frac{1}{b!}<br>\end{aligned}<br>$$<br>显然后面就是一个卷积。</p><p>发现最终得到的系数有如下的情况，假设之前得到的系数是 $b_j$。</p><p>我们有等式：<br>$$<br>\alpha_k \frac{1}{k!(n - k - 1)!} &#x3D; b_k \frac{1}{(n - k - 1)!}<br>$$<br>显然 $\alpha_k &#x3D; b_k \times k!$。</p><hr><h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><blockquote><p>我们正式开始解决这个问题。</p></blockquote><p>考虑设生成函数 $F(u, v, t)$ 表示有 $u$ 个 $&gt;$，$v$ 个 $&lt;$ 其中 $x$ 的取值为 $t$ 的生成函数，我们考虑自身的映射。<br>$$<br>F(t) &#x3D; 1 + u\int_{0}^ t F(x) dx + v\int_{t}^{1} F(x) dx<br>$$<br>积分不好做，我们求导一下，注意 $F(0) &#x3D; F(1) &#x3D; 0$。<br>$$<br>F’ &#x3D; (u - v) F<br>$$<br>解微分方程得到：<br>$$<br>F &#x3D; Ce^{(u - v)t}<br>$$<br>带入 $t &#x3D; 0, t &#x3D; 1$ 设 $I &#x3D; \int_{0}^1 F(x) dx$ 可以列出二元方程：<br>$$<br>\begin{cases}<br>    1+vI&#x3D;C\\<br>    1+uI&#x3D;C\mathrm{e}^{(u-v)t}<br>\end{cases}<br>$$<br>得到：<br>$$<br>\begin{cases}<br>    C &amp;&#x3D; \dfrac{u-v}{u-v\mathrm{e}^{u-v}}\\<br>    F &amp;&#x3D; \dfrac{(u-v)\mathrm{e}^{(u-v)t}}{u-v\mathrm{e}^{u-v}}<br>\end{cases}<br>$$<br>我们考虑左右两边的情况，不要忘记我们的 $F$ 是表示排列末尾的情况，所以我们合并的时候对于右边的生成函数需要倒置。</p><p>我们设 $x$ 表示元素的总个数，设 $y$ 表示下降的个数。</p><p>对于左边我们换元 $u &#x3D; xy, v &#x3D; x$ 对于右边是 $u &#x3D; x, v &#x3D; xy$。</p><p>之后写出函数：<br>$$<br>\begin{aligned}<br>    L &amp;&#x3D; \frac{(1-y)\mathrm{e}^{x(1-y)t}}{(1-y\mathrm{e}^{x(1-y)})}\\<br>    R &amp;&#x3D; \frac{(y-1)\mathrm{e}^{x(y-1)t}}{(y-\mathrm{e}^{x(y-1)})}\\<br>    &amp;&#x3D; \frac{(1-y)\mathrm{e}^{x(y-1)(t-1)}}{(1-y\mathrm{e}^{x(1-y)})}<br>\end{aligned}<br>$$</p><hr><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>考虑取 $p, q$ 分别表示左右两边的形式幂级数，设 $n_1 &#x3D; k - 1, n_2 &#x3D; n - k$。</p><p>合并生成函数可以得到：<br>$$<br>[ y^m p^{n_1} q^{n_2} ] (1-y)^2 \frac{\mathrm{e}^{pt(1-y)+q(1-t)(1-y)}}{(1-y\mathrm{e}^{p(1-y)})(1-y\mathrm{e}^{q(1-y)})}<br>$$<br>发现对于 $p, q$ 都附带一个 $(1 - y)$ 考虑提出来：<br>$$<br>(1-y)^{n+1} \frac{\mathrm{e}^{pt+q(1-t)}}{(1-y\mathrm{e}^{p})(1-y\mathrm{e}^{q})}<br>$$<br>我们既然需要提取系数，就考虑因式分解能否得到一个简单的形式：<br>$$<br>(1-y)^{n+1} \mathrm{e}^{pt+q(1-t)} \frac 1{\mathrm{e}^p -\mathrm{e}^q} \left(\frac{\mathrm{e}^p}{1-y\mathrm{e}^p} - \frac{\mathrm{e}^q}{1-y\mathrm{e} ^q}\right)<br>$$<br>很遗憾我们出现了 $\dfrac{1}{e^p - e^q}$ 这样出现在指数上的生成函数我们不能求出系数，试试求导（套路）。<br>$$<br>\begin{aligned}<br>&amp; \quad (1-y)^{n+1} \mathrm{e}^{pt+q(1-t)} \frac{p-q}{\mathrm{e}^p-\mathrm{e}^q}\left(\frac{\mathrm{e}^p}{1-y\mathrm{e}^p} - \frac{\mathrm{e}^q}{1-y\mathrm{e}^q}\right) \<br>\end{aligned}<br>$$<br>考虑这个 $e^p - e^q$ 肯定是需要消除的，我们唯一能做的就是将其看成一体，也就是之后肯定需要考虑 $p - q$，我们决心将 $e^q$ 除掉。<br>$$<br>\begin{aligned}<br>&amp; &#x3D; (1-y)^{n+1} \mathrm{e}^{pt+q(1-t)} \mathrm{e}^{-q} \frac{ (p-q) }{\mathrm{e}^{p-q}-1}\left(\frac{\mathrm{e}^p}{1-y\mathrm{e}^p} - \frac{\mathrm{e}^q}{1-y\mathrm{e}^q}\right) \\<br>&amp; &#x3D; (1-y)^{n+1} \mathrm{e}^{(p-q)t} B(p-q) \left(\frac{\mathrm{e}^p}{1-y\mathrm{e}^p} - \frac{\mathrm{e}^q}{1-y\mathrm{e}^q}\right)<br>\end{aligned}<br>$$<br>后面的 $B(x)$ 表示伯努利数 $B(x) &#x3D; \dfrac{x}{e^x - 1}$，这个很好处理。</p><p>然后考虑提取右边部分的系数，将 $(1 - y)^{n + 1}$ 放入。为了方便两部分可以看成 $G(x) &#x3D; F(e^x) &#x3D; \dfrac{x}{1 - yx} \times (1 - y)^{n + 1}$。</p><p>直接展开：<br>$$<br>F(x) &#x3D; [y^m] \sum_{i \ge 0} (1 - y)^{n + 1} y^i x^{i + 1}<br>$$<br>我们知道我们迟早要带入 $F(e^x)$ 我们看看 $F$ 是否有什么性质。</p><p>我们继续展开 $F$：<br>$$<br>F(x) &#x3D; \sum_{j &#x3D; 0} ^ {n - 1} x^{j + 1} \binom{n + 1}{m - j} (-1)^{m - j}<br>$$<br>因为 $x^{j + 1}$ 不好看我们设 $xf(x) &#x3D; F(x)$。</p><p>对于解决这类问题我们通常使用求导，但是这里其实可以偷个懒，因为没有别的项，两项的递推很好求出，直接作比即可。<br>$$<br>\begin{aligned}<br>    (n-m+1+i)f_i &amp;&#x3D; -(m-i+1)f_{i-1} + [i&#x3D;0]C\\<br>    (n-m+1)f(x) + xf’(x)&amp;&#x3D; -mxf(x) + x^2 f’(x) + C\\<br>    (n-m+1+mx)f(x) + (x-x^2)f’(x)&amp;&#x3D;C<br>\end{aligned}<br>$$<br>这里的 $f_0$ 事实上就是 $\binom{n + 1}{m} (-1)^m$，为了方便我们直接让其为 $(n - m + 1)\binom{n + 1}{m}(-1)^m$。</p><p>之后带入 $G$ 得到：<br>$$<br>\begin{aligned}<br>    (n+1-m+m\mathrm e^x)g(x)+(1-\mathrm e^x)g’(x) &amp;&#x3D;C\\<br>    ((n-m)\mathrm e^{-x} +m+1)G + (\mathrm e^{-x}-1)G’ &amp;&#x3D; C<br>\end{aligned}<br>$$<br>考虑展开求出 $G$，提取 $[x^i]$ 得到：<br>$$<br>\begin{aligned}<br>(n-m)\sum\limits_{j&#x3D;1}^i \frac{(-1)^j}{j!} G_{i-j} &amp;+ (n+1) G_i \\<br>+\sum\limits_{j&#x3D;1}^i \frac{(-1)^j}{j!} (i-j+1) G_{i-j+1} &amp;&#x3D; [i&#x3D;0]C<br>\end{aligned}<br>$$<br>最终可以得到：<br>$$<br>\begin{aligned}<br>(n-i+1)G_i &amp;&#x3D; [i&#x3D;0]C \\<br>-(n-m)\sum\limits_{j&#x3D;0}^{i-1} G_j \frac{ (-1)^{i-j} }{(i-j)!} &amp;-\sum\limits_{j&#x3D;1}^{i-1} j G_j \frac{ (-1)^{i-j+1} }{(i-j+1)!}<br>\end{aligned}<br>$$<br>直接使用半在线卷积即可。</p><p>最后来处理原式：<br>$$<br>(1-y)^{n+1} \mathrm{e}^{(p-q)t} B(p-q) \left(\frac{\mathrm{e}^p}{1-y\mathrm{e}^p} - \frac{\mathrm{e}^q}{1-y\mathrm{e}^q}\right)<br>$$<br>我们只举一边的例子，考虑求 $e^{(p - q)t}B(p - q)G(p)$，令 $q &#x3D; rp$ 进行换元。<br>$$<br>\begin{aligned}<br>&amp;\sum_{i \ge 0} [ p^{n - i - 1} ] G(p) \times [r^{n2}] (1 - r) ^ i \times [p^i] B(p)e^{pt} \\<br>&#x3D; &amp; \sum_{i \ge 0} Q_{n - i - 1} \times [p^i] B(p) e^{pt}, Q_{n - i - 1} &#x3D; [p^{n - i - 1} ] G(p) \times [r^{n2}](1 - r) ^ i \\<br>&#x3D; &amp; [p^{n - 1}] Q(p) B(p) e^{pt} \\<br>&#x3D; &amp; \sum_{i \ge 0} \frac{t^i}{i!} [p ^ {n - 1 - i}] Q(p)B(p)<br>\end{aligned}<br>$$<br>这样就做完了，复杂度是 $O(\dfrac{n \log^2 n}{\log \log n})$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.2e6</span> + <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, G = <span class="number">3</span>, invG = <span class="number">332748118</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(mi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[maxn], w[<span class="number">2</span>][<span class="number">21</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &lt; maxn ? inv[x] : <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line"><span class="keyword">int</span> lim, len, rev[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(lim = <span class="number">1</span>, len = <span class="number">0</span>; lim &lt;= x; lim &lt;&lt;= <span class="number">1</span>, ++ len) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> op = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(A[i], A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid = <span class="number">1</span>, ts = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>, ++ ts) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, c = (mid &lt;&lt; <span class="number">1</span>); j &lt; lim; j += c) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span>* w1 = w[op == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>][ts];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mid; ++ k) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = A[j + k], y = <span class="number">1ll</span> * w1[k] * A[j + k + mid] % mod;</span><br><span class="line">                A[j + k] = (x + y) % mod;</span><br><span class="line">                A[j + k + mid] = (x - y + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">Inv</span>(lim);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) A[i] = <span class="number">1ll</span> * A[i] * z % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[maxn], fac[maxn], finv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    finv[x] = <span class="built_in">ksm</span>(fac[x], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) finv[i] = <span class="number">1ll</span> * finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++ i) inv[i] = <span class="built_in">ksm</span>(i, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">20</span>; ++ t) &#123;</span><br><span class="line">        <span class="keyword">int</span> buf0 = <span class="built_in">ksm</span>(G, (mod - <span class="number">1</span>) / (<span class="number">1</span> &lt;&lt; t));</span><br><span class="line">        <span class="keyword">int</span> buf1 = <span class="built_in">ksm</span>(invG, (mod - <span class="number">1</span>) / (<span class="number">1</span> &lt;&lt; t));</span><br><span class="line">        w[<span class="number">0</span>][t][<span class="number">0</span>] = w[<span class="number">1</span>][t][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; (<span class="number">1</span> &lt;&lt; t); ++ k) &#123;</span><br><span class="line">            w[<span class="number">0</span>][t][k] = <span class="number">1ll</span> * w[<span class="number">0</span>][t][k - <span class="number">1</span>] * buf0 % mod;</span><br><span class="line">            w[<span class="number">1</span>][t][k] = <span class="number">1ll</span> * w[<span class="number">1</span>][t][k - <span class="number">1</span>] * buf1 % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[a] * finv[b] % mod * finv[a - b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x &amp; <span class="number">1</span>) ? mod - <span class="number">1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cpy(a, b, c) memcpy(a, b, sizeof(int) * (c))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(a, b) memset(a, 0, sizeof(int) * (b))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        g[l] = <span class="number">1ll</span> * g[l] * <span class="built_in">Inv</span>(n - l + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ln = mid - l + r - l + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Solve</span>(l, mid);</span><br><span class="line">    <span class="built_in">getrev</span>(ln);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s1[maxn], s2[maxn], s3[maxn], s4[maxn], ans[maxn];</span><br><span class="line">    <span class="built_in">clr</span>(s1, lim), <span class="built_in">clr</span>(s2, lim), <span class="built_in">clr</span>(s3, lim), <span class="built_in">clr</span>(s4, lim), <span class="built_in">clr</span>(ans, lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid - l; ++ i) &#123;</span><br><span class="line">        s1[i] = <span class="number">1ll</span> * g[i + l] * (n - m) % mod;</span><br><span class="line">        s2[i] = <span class="number">1ll</span> * g[i + l] * (i + l) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r - l; ++ i) &#123;</span><br><span class="line">        s3[i] = <span class="number">1ll</span> * <span class="built_in">sign</span>(i) * finv[i] % mod;</span><br><span class="line">        s4[i] = <span class="number">1ll</span> * <span class="built_in">sign</span>(i + <span class="number">1</span>) * finv[i + <span class="number">1</span>] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">100</span> || mid - l &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sr = mid + <span class="number">1</span> - l; sr &lt;= r - l; ++ sr) <span class="keyword">for</span>(<span class="keyword">int</span> sl = <span class="number">0</span>; sl &lt;= mid - l &amp;&amp; sl &lt;= sr; ++ sl) &#123;</span><br><span class="line">            ans[sr] = (ans[sr] + <span class="number">1ll</span> * s1[sl] * s3[sr - sl] % mod + <span class="number">1ll</span> * s2[sl] * s4[sr - sl] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NTT</span>(s1), <span class="built_in">NTT</span>(s2), <span class="built_in">NTT</span>(s3), <span class="built_in">NTT</span>(s4);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) ans[i] = (<span class="number">1ll</span> * s1[i] * s3[i] % mod + <span class="number">1ll</span> * s2[i] * s4[i] % mod) % mod;</span><br><span class="line">        <span class="built_in">NTT</span>(ans, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++ i) g[i] = (g[i] - ans[i - l] + mod) % mod;</span><br><span class="line">    <span class="built_in">Solve</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">//    if(r - l &gt; 5000) printf(&quot;(%d, %d)\n&quot;, l, r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span>* B, <span class="keyword">int</span> ln)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ln == <span class="number">1</span>) <span class="keyword">return</span> B[<span class="number">0</span>] = <span class="built_in">Inv</span>(A[<span class="number">0</span>]), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s1[maxn];</span><br><span class="line">    <span class="built_in">Inv</span>(A, B, (ln + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">//    printf(&quot;ln = %d\n&quot;, ln);</span></span><br><span class="line"><span class="comment">//    for(int i = 0; i &lt; ln; ++ i) printf(&quot;%d &quot;, B[i]);</span></span><br><span class="line"><span class="comment">//    puts(&quot;\n &quot;);</span></span><br><span class="line">    <span class="built_in">getrev</span>(ln &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cpy</span>(s1, A, ln), <span class="built_in">clr</span>(s1 + ln, lim);</span><br><span class="line">    <span class="built_in">NTT</span>(s1), <span class="built_in">NTT</span>(B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) B[i] = <span class="number">1ll</span> * B[i] * (<span class="number">2</span> - <span class="number">1ll</span> * s1[i] * B[i] % mod + mod) % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(B, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ln; i &lt; lim; ++ i) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P[maxn], Q[maxn], B[maxn], rs[maxn], F[maxn], T[maxn], sA[maxn], ans[maxn];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 1 1</span></span><br><span class="line"><span class="comment">1 6 3 4 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* B,<span class="keyword">int</span>* as,<span class="keyword">int</span> ln)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getrev</span>(ln &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line">    <span class="built_in">clr</span>(a, lim), <span class="built_in">clr</span>(b, lim);</span><br><span class="line">    <span class="built_in">cpy</span>(a, A, ln), <span class="built_in">cpy</span>(b, B, ln);</span><br><span class="line">    <span class="built_in">NTT</span>(a), <span class="built_in">NTT</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++ i) as[i] = <span class="number">1ll</span> * a[i] * b[i] % mod;</span><br><span class="line">    <span class="built_in">NTT</span>(as, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m, K);</span><br><span class="line">    <span class="keyword">int</span> n1 = K - <span class="number">1</span>, n2 = n - K;</span><br><span class="line">    <span class="built_in">init</span>(n + <span class="number">5</span>);</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1ll</span> * <span class="built_in">sign</span>(m) * <span class="built_in">C</span>(n + <span class="number">1</span>, m) % mod * (n - m + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="built_in">Solve</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//    for(i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, g[i]);</span></span><br><span class="line">    <span class="built_in">getrev</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; ++ i) B[i] = finv[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">Inv</span>(B, rs, n + <span class="number">1</span>), <span class="built_in">cpy</span>(B, rs, n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(i = 0; i &lt; n; ++ i) r1(B[i]);</span></span><br><span class="line"><span class="comment">//    Inv(B, rs, n);</span></span><br><span class="line"><span class="comment">//    for(i = 0; i &lt;= n; ++ i) printf(&quot;%d &quot;, B[i]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) Q[n - i - <span class="number">1</span>] = <span class="number">1ll</span> * g[n - i - <span class="number">1</span>] * <span class="built_in">sign</span>(n2) % mod * <span class="built_in">C</span>(i, n2) % mod;</span><br><span class="line"><span class="comment">//    for(i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, Q[i]);</span></span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line">    <span class="built_in">Mul</span>(Q, B, Q, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) P[n - i - <span class="number">1</span>] = <span class="number">1ll</span> * g[n - i - <span class="number">1</span>] * <span class="built_in">sign</span>(n1 - i) % mod * <span class="built_in">C</span>(i, n1) % mod;</span><br><span class="line">    <span class="built_in">Mul</span>(P, B, P, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) F[i] = <span class="number">1ll</span> * (Q[n - i - <span class="number">1</span>] - P[n - i - <span class="number">1</span>] + mod) * finv[i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(i = n; i &gt;= <span class="number">1</span>; -- i) F[i] = <span class="number">1ll</span> * F[i - <span class="number">1</span>] * <span class="built_in">Inv</span>(i) % mod;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(i = 0; i &lt; n; ++ i) printf(&quot;%d &quot;, F[i]);</span></span><br><span class="line"><span class="comment">//    puts(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    puts(&quot;OK&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) F[i] = <span class="number">1ll</span> * F[i] * fac[n - i - <span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) T[i] = finv[i];</span><br><span class="line">    <span class="built_in">Mul</span>(F, T, sA, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) ans[i] = <span class="number">1ll</span> * sA[i] * fac[i] % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m; ++ i) left = (left + <span class="number">1ll</span> * <span class="built_in">C</span>(n + <span class="number">1</span>, i) * <span class="built_in">ksm</span>(m + <span class="number">1</span> - i, n) % mod * <span class="built_in">sign</span>(i) % mod) % mod;</span><br><span class="line"><span class="comment">//    printf(&quot;left = %d\n&quot;, left);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) left = (left - ans[i] + mod) % mod;</span><br><span class="line">    left = <span class="number">1ll</span> * left * <span class="built_in">Inv</span>(n) % mod;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) ans[i] = (ans[i] + left) % mod;</span><br><span class="line"><span class="comment">//    printf(&quot;left = %d\n&quot;, left);</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>我也不知道我为啥跑得这么慢，反正最劣解就是了，但是其实半在线卷积没有那么难写。</p><p>从大概是去年这个时候接触多项式，就听到了这个是一个神仙题，看着 $\tt alpha1022$ 的博客感慨 <code>这是什么鬼啊！！！</code>。</p><blockquote><p>之后认识他是我在 $\tt luogu$ 群问问题的时候，这位大佬来教我的，<del>结果发现我是式子看错了</del>。</p></blockquote><p>算继省选和诸多支线赛事失利的一种安慰吧，来写写这个题。</p><p>感谢给予我实际帮助的所有人：</p><ul><li><p>$\tt expwmh$ 帮我推了 $1$ 个式子，<del>虽然最终也没有用到</del>。</p></li><li><p>$\tt \text{野兽先辈}$，数竞国家集训队大佬，解答了我 $4$ 个困惑。</p></li><li><p>$\tt silhouette$ 给予精神上的支持。</p></li><li><p>$\tt macesuted$ $D$ 了我好久。</p></li><li><p>$\tt hater$ 鸽鸽好强！！！</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;593-新年的军队&quot;&gt;&lt;a href=&quot;#593-新年的军队&quot; class=&quot;headerlink&quot; title=&quot;#593. 新年的军队&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://uoj.ac/problem/593&quot;&gt;#593. 新年的军队&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="UOJ题解" scheme="https://legendgod.ml/categories/UOJ%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="生成函数" scheme="https://legendgod.ml/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="概率论" scheme="https://legendgod.ml/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>P4548 [CTSC2006]歌唱王国</title>
    <link href="https://legendgod.ml/2022/05/29/lg-solution-4548/"/>
    <id>https://legendgod.ml/2022/05/29/lg-solution-4548/</id>
    <published>2022-05-29T12:17:00.000Z</published>
    <updated>2022-11-11T11:18:54.377Z</updated>
    
    <content type="html"><![CDATA[<p>我们考虑最终答案为 $i$ 的概率为 $f_i$。</p><p>考虑转移的时候肯定是通过 $\tt border$ 进行转移，这样就可以通过 $\tt Dp$ 进行解决。</p><p>考虑使用一种另外的方法，我们思考 $f_i$ 肯定是通过一个不合法的情况进行转移的，我们考虑设 $g_i$ 表示长度为 $i$ 但是没有结束。</p><p>通过生成函数表示，显然有等式 $ans &#x3D; F’(1)$。且 $F$ 和 $G$ 的关系是 $F + G &#x3D; Gx + 1$，就是考虑之后再加入一个字符的贡献。</p><p>之后考虑先前 $\tt Dp$ 的 $\tt border$ 转移，显然对于 $G$ 加入某些字符是可以使得其满足条件的。</p><p>假设加入了字符串 $S$ 要么 $S$ 就是要求的字符串，要么就是因为之前已经有过一部分了，不妨考虑我们直接加入要求字符串，之后减去多算的，因为多算的部分肯定是 $\tt border$。</p><blockquote><p>考虑已经有的部分是 $A$ 后面的部分是 $B$ 满足 $A + B &#x3D; L$ 那么我们有 $L - B &#x3D; A$ 也就是说 $A$ 满足前缀等于后缀，所以是 $\tt border$。</p></blockquote><p>有等式 $G \times (\frac{1}{m}x)^L &#x3D; \sum_{i &#x3D;1} ^ L a_i F \times (\frac{1}{m}x)^{L - i}$。</p><p>其中 $a_i$ 表示长度为 $i$ 是不是 $\tt border$。</p><p>我们梳理一下：<br>$$<br>F + G &#x3D; Gx + 1 \\<br>G \times (\frac{1}{m}x)^L &#x3D; \sum_{i &#x3D;1} ^ L a_i F \times (\frac{1}{m}x)^{L - i}<br>$$<br>我们最终的答案是 $F’(1)$ 考虑表示一下 $F’ &#x3D; G’x + G - G’$。</p><p>也就是说 $F’(1) &#x3D; G(1)$。</p><p>发现下面式子循环的上限制是 $L$，是否可以直接求出 $G$。</p><p>考虑带入得到 $G(1) \times \frac{1}{m^L} &#x3D; \sum_{i &#x3D; 1} ^ L a_i F(1) \times \frac{1}{m^{L - i}}$。</p><p>我们发现 $F(1) &#x3D; 1$ 因为是算概率，所以全部概率和就是 $1$。</p><p>我们有 $G(1) &#x3D; \sum_{i &#x3D; 1} ^ L a_i m^i$。</p><p>直接求出 $a$ 就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, pw[maxn], nxt[maxn], s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fastmod</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">__uint128_t</span> LLL;</span><br><span class="line">    ULL b, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ULL b)</span> </span>&#123; <span class="keyword">this</span>-&gt;b = b, m = <span class="built_in">ULL</span>((<span class="built_in">LLL</span>(<span class="number">1</span>) &lt;&lt; <span class="number">64</span>) / b); &#125;</span><br><span class="line">    <span class="function">ULL <span class="title">operator</span><span class="params">()</span> <span class="params">(ULL a)</span> </span>&#123;</span><br><span class="line">        ULL q = (ULL)((<span class="built_in">LLL</span>(m) * a) &gt;&gt; <span class="number">64</span>);</span><br><span class="line">        a -= q * b;</span><br><span class="line">        <span class="keyword">return</span> a &gt;= b ? a - b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">border</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span>(s[j + <span class="number">1</span>] == s[i]) ++ j;</span><br><span class="line">        nxt[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m);</span><br><span class="line">    M.<span class="built_in">init</span>(mod);</span><br><span class="line">    n %= mod;</span><br><span class="line">    <span class="keyword">for</span>(pw[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span>; i &lt; maxn; ++ i) pw[i] = <span class="built_in">M</span>(pw[i - <span class="number">1</span>] * n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = m, ans = <span class="number">0</span>; t &gt;= <span class="number">1</span>; -- t) &#123;</span><br><span class="line">        <span class="built_in">r1</span>(m), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">r1</span>(s[i]);</span><br><span class="line">        <span class="built_in">border</span>();</span><br><span class="line">        <span class="keyword">for</span>(i = m; i &gt;= <span class="number">1</span>; i = nxt[i]) ans += pw[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%0*d\n&quot;</span>, <span class="number">4</span>, ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们考虑最终答案为 $i$ 的概率为 $f_i$。&lt;/p&gt;
&lt;p&gt;考虑转移的时候肯定是通过 $\tt border$ 进行转移，这样就可以通过 $\tt Dp$ 进行解决。&lt;/p&gt;
&lt;p&gt;考虑使用一种另外的方法，我们思考 $f_i$ 肯定是通过一个不合法的情况进行转移的，我</summary>
      
    
    
    
    <category term="洛谷题解" scheme="https://legendgod.ml/categories/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="生成函数" scheme="https://legendgod.ml/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
    <category term="字符串" scheme="https://legendgod.ml/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>机房守则</title>
    <link href="https://legendgod.ml/2022/05/28/laws_in_computer_room/"/>
    <id>https://legendgod.ml/2022/05/28/laws_in_computer_room/</id>
    <published>2022-05-28T11:08:20.000Z</published>
    <updated>2022-11-11T11:18:54.377Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7e0c68ab89d6aff6a77796b70fda8d5fade5ad90c28d307d7e4c76243b093685">83688c116208998129503a5ac0b0c9e5888b5d6deffca1bde9f53a6d85fea0d53eb39cc1b8988b1e460a9458ffa29c37454946d981331790a1a25a2af4e61c701888b3e3ae8118300a896af69f417396480d4e26ce2ef99c5665b22dd9cd9a4d3e2d69c0b09d92cf3e342a7d5628eb9fe2dfcbbb8345ec741aa731f39969e4037241a95a869b633b494082a2bf6c1e6bb029bd994a0cf1f00da393b83005dd78c62b9b1fced11618ca841d7da0f135e460abb94196fcd7aae8dd6de991a3503e1296c67acf8a667d19e3fadb5ffe569f7ec8d11f2f7e520f016f36fc00cc476c0dbd7418a2a32172e79fddc56383b05f8b1209233b5ce232046e753ee5ce2ab59f14c81b9f4fba39be17f5194073c3fdb6f4ec044b65bc78d37c7213eb88654c2dcb02301e248a87908770de9991a7e75288241537c350e13fd02ac7652dddb6e17717d0ed80a5ba01098d997dd7e36101b5ef57818bb413a031cbc90c1a7d64406bce513aa35d045a07d865f5302bcb12c7b694c5e2b52d320c46c5932c6a7ad069cba0b19e4965f8b22af1dfce026f826523bd274f4a49455fdc11afdef79d8e6e817579f082588be7d5864a692c6cdcc0294eac15f78c057838940f262ff1cb201e19ef50b15d411836476e0dcca98f07bea8e1a03ee6734dafaa30d30824b9991149ab21d26bd6c6962d9a614c05d905df05240a5121234475bd26b925e6ccbc6dd029471456f1a18f7f1e7f34d59526ae34c8999a1cc9d88ed5c62c29de51cbc9753d6340081af921c6c8b9e28282c15b55ad4b23dc8f08905d65004de4b9f10c26e21ec716d015f7b0f8abb91a534faa9a3ca678ad124c9ef2823de6a47a767678536a24ba4d83b26b31f2123ac833c294cd151e8cf531d097c759c1b823c1f827afe21c8433a5221306833034fe1bb2192b0c0ef99b1a4f0d9841de0cf1296dfe71f15f808e4a9820d0f0a2bf4f3e02cee433e2045d3cf630668b32e196503d7df61ec31d8d64be888bab4301d49abb8982f12a21df7be69efd590e6860d3f84d489b17159e1451563474fe82fe2a678d0cc76c676fe87362d7d0e444b61567834c3c8409354584e9b38ada1b5dbebb399773e3e8320fafcf7c3b7838d7ad20d4aab702f415dcff992eb1ee64d503495aa106af6246ed0b3b38970a47e740cd57f65c3d073e9def7bedd857349992fb721f6096297720e3fb165a6fbe5d6bff58d52d90f33c1dda9c2ad9a035435d90549f99ef383872f02cb514cbc9ea12cf0f42bf19146a397049be24e9dabf5067f074d38cfab55eda44cd5064823b48e1805b56b8e013d4fb2e794e8a1b1b9cc6a026d83ff1774f22e6a5ad3a344218385052ee8253fb1d7e02ea729cabc6936902c4dc3cba422f45ac26d2ede2a16eaa96e9c484e6d45fdca953d7c23eee666e5784c1f23427ef4f7f4339443a5c620a40f30b6bdd9aab31fa76d2d21c1289d9b94250be7206aa5c4635537192e85e0994b88a0e0c5d79e7e02d35387c9c6595af3f064dd5579ca1dcd6eda65f7e65e35d9b552cf0540e49c45d4ca29127a17f986a89d0c2816d19d14f56a9d25f37f951e72506173c2fbe12de9cbc67c029e24d5afb89921c3563f2a31353a5a11c09786afddb08eee9884687d45e869364d638873315b429014c27a4650a4a936f6e8f4fd60e0203f415d9334251e3fd5cca215af63cd7a5a3bef48d2c46a0d3708e8caa49dab9131f06d0f287c0058e52a71910c16d7f660790450ee3a29d2c13a75df5c081e58dec730ab2c2e9f11f887ea542a2aeb7952ebb4d2d624815d0cef9e086bbeb79034b5908a0ed16c5373557a03e9105d0b772aded62d2d9a4d5f837a80d75ee5c2fe615fd201ab2b3854f8cd1b8c1c8d2c642e9e01ce23b246534367e1c34af983ef35939cb407ca26c62c5c5e6729c45bfeafd22550d2a2a70bc497bab3bceb2d6c200efaf3de5c836b43b4bc71b4627d037795e70170be50eef502fc7e2a41d50e7ce2dae75c4e020a8a2182c883b666a04f3c9236a3f462776d85d9c0c7e70c07df6d178343cd60593b257b2fef204770eabdc0cb08ead33c59505248cee33e8784ba8f6c2d31fe712b3770a14b09143246b6b93e3f6a2ef1a44778335a501a5dcb2246dbedfa90241a3f07e3daae625a18ac3b13c846336d36564bdee0f358daa2ebdfc338f09162a74b77bbf28778a2a4d32ca64b6a897a560901a04693cbf1c0ed1ca11a5bd649d319b23e6ad0ecd61d1daaa98e107eae223e1282cf5b2642cef93830652c142428b473bad56bfdb9eddb8736880a2820bda9659b2af412bca76e8f97bd283d1a23ade8d128d971f640096d8c2b51a27eea312ff377acac0f872975b6580ae6ec4a506dd3965119d4e641d3c1b6ba1c05a819a1c03840a92c4900954333cba252953fd99faf6ea34b31a0395011fd845eef815d3386a7f41b16720ab04107fcf46aeba5f9123ac19b7cd5a63fa8aef5ec47264ac560d07158277cc414964c87ed47616aabc1a7a81a265183a9b18325bb5c5d175bdbe509214dccd8a39c4d5dc77e6dfe8ed1d0b7c3b77d91dafca747ac07ccc2985c1a1ae4644c6f4473b52f21f0499e924382374c7b028eee2964826d5cba51f2285c0f51d973538a3518865aa772063a8d4d7d76ceb49331108bccbf333708964af61f7f54886ba065446d783aa63fee870e95a9773e25d7f3ad75560efd44ed1e98ef111d5e31d00e63d891d522407a0e6085279e3e7207c9f7ae2bc66d6c3284d17ef448b703835422422402bc883c7d7ba5224526bd9413026309ba35799065b0b36506ee6a31f834e312dc47bf9cde023458b3114037c5b0b12c1d09883cb0331160091a7535e8ea8d0abe5fb8e5afb35167059180fb1ef1d924bfbf97fc852df14830d7525750882ccc5bf4d8ebdecf529f764106f100873a7bae1b669137e01c30227e6db2137c103c7049b0fb0a779d90d4fdb11e00835f00b4b54b3d988c6bbf10f8277ecd8ba6f6e57cc09ca0d5fd67d5df9c79456ade0d740ac94483cbffcb861bc5f031482120eb455885fe4e5049a78ec82f300541c2f21ae298782c63fd624df4672310934cc0d75a350c89864e5999b9b774723dc3fcb79caccbb2e91f954134e5f1ef08386ec63fec8f4a1884449c0e391ecb3ebe4b63321aec9d9f7d4b8bb8e846d587ce34c7c02bccab0c6ac441eeb078af8cea89af48e7c3060c53a5e05450908271fea7d1876647cda5ef87142f699e43d22d27c9e16e86983af8bdd865880811798b7a997bf48e51ec5ffe6923953d49914654e8166d12a30894a01438d354f6c5692bff685759911a67dcb1121a7387905728ee5ae4731807ef47508aba8a3c6af6590ca40f771084ed82668403ed9af75cd5dd5180899aea15f273c04f744983fcbf85f93046af35e53ac3d7a66f999cb1c021781c7c4cd42f714246ab36adaf59cc908c07435d5a4b845be72d12ad47154ca808173f0a9c675750b3ff3f270cd57393f553622889fc705376f90582b15668d8ea726062e7350c2747964a89b942adcccb163e1377dbd1066be86c88220b49fc157faa7a8b4fda0bc92dea4cfd2ebaebfe9f41bf9da0a756d7cf2b6ea2cbb93bb49ddc3d7157e85b742769f39a1bfb285e16147136cab8f43fe9ce9c7afc109d82d2b783f5bee78690a49da9e9b77e812cc641306382b41697796bffedf28c3de7426676d5ba1b147953bb8695519e7ac68881c2aa8f167513683e3acb26c478d984477180cae8cf3894cf301d4746fe84b865320e45c7bfdb6d9c9ba9341ad7b6883ef3c695c38e1b8fbeb3e51085212c6e780b4e7465464e0e38bc97535979c79382e34073c327621a0177b913c130f1794934efe36170a839cd987d1e9f825d7c912d8e495c8ef06a38e5b10d3373723a4e34c7fa22ef8c993c7c2330cd3690371450d635328e2669b7fdcaf5764b9706a13ee2890d3d55b13d82fc90b46d64611336d5b766e1642e2a0d727102345f02a0c66ed206b95111ae599cd3d7b99ea3aaaf1d6109fc0035787a1fd0a70cfd63eeab357f1f612f278f5d1d628a9aeb11f6e7190627124bd317d4db3ddf44793e15b30ee94a22e62ec040558b492a20f15f0414296dd677ee2ca8a40c25369ec746e5adde4d79388fa26c4411009e43321e9ec7e9abc6b848fb7a90bbee63d9c2e545241379b575aa1d6492540897c1c57e0355edb1eeac011b42b34f2978799af7e185f41ea29ab93bfa883810007526f1a332c078f7e577e929eba78d3ba47913626881d2ca19ece0925a93218e920d53655d0c2d0f1840e150fb2ddb620eb12691248068d998635209b751e2cc483160556e7df6d22307121773555908dce72eeeee07e07dc2d0a9b346e21cb3dc1136f2d898816c6e344879cf61d994f62b3557ae0c4c35f1631995fa53be8c96d0b1088171ebacf27cef242ad761e52437ec9b3bb8593e7ea3592817a13e07d522ed7977a2369475824ac92af8183668a98781520b8086d1a26189e291c733f19249cea0f087e3148bf9f69dbf682672031a1b18ba12b70b69139b2399234657086286f30af92ff59c02c1cea476764a32a8a4537e205850df510b24187f2ba0814e5ac1454d67c45fb57f1d91840ab48d39640a4e5a7159ef810e33c67fc3e165e992f9453d585bd5142caf48d24af55b82f42c4e5994aca12b8d6848552944dbe1103e5782535c76280e2588206f0f1f56a6b420f8464dfd154e2358a9520df8f5a932cd682273360053809829efbc32de8c6edad76044f8c5af2e29b1def816faa1fa36c55a7a2d24c054d629dd1a885ff4bd826f284696e7df2b6b12e614415df40e4fa9f49afb5e2150d476dd7dd7ab81dfbe6e8d24457bade612020c33fb3da4246971ff2541bd19685333c196659df6fab976e6627a0bc07ceeb3451d99b77e0c69edd27be4906769577f4245c1df2ecc71cb58c65d5e29a11fa8e4eff4813eb717c681bcf7a8ea2c4190f81c2768aa6d0e6cec530a48d84f8ee86a2779e61b0ec0089ac682751cf1715107c6785e2a0b5adefdada22941c75f2e664caefbee600172f8b636558884a760e267549503aa25af036da25cae31f75fb741fe74c8087cc77697652d1ef091223d7d10aaad6165bb4ce83616b7012c87cb2310ce3e298819f7ea899c95f3a86d9cb3c3141ac6e0de4d03c0961b7b711b03c91f93edfed0a44479567019664af1b5f951896b7379089042061ff9fa72e2b8ee870ab174d1a8117f99c756e8e1916625b74326fcf377ea210cc6219b7e9c18962f1f8acc4b4bc57204fab9995c831852502637a748d0e02f089fec0f268e19f2ee02df939b9674ae93a2c1b3b640bc7606a5988f27045a1a69cb8fd865eecb07c2d3fb8e87c0615743f9fac4d3b4414b6a84bf170a405a43b16dbb458351fdfbb751d3491c2a4140a51a14ed56111e65f63d562be095a86b0cd4be20b90415c79aedafbb9f4f7d503ebce58cf125486258c0c3917e2da25d919e749d3161f391681bc00009ffb5e6d1197711c213b5bc371bfe968b4e647901db5687422fa4d89d943b776591de7fd629484bb0ec3aaf3a5a0e78382927fd4c4860f57ef33cff6efee52c561aed25bde9d04b87d3d99a62561bfd50d9718207d36edd48b825571662410f7b29ce5986b1e28d91564a07b4964f60b78e50c5a4965d64d3844c659569b3af1987f75858fd6158c06ef9de7aef94b5bcb3227cc1caae48edd41ff04095dcd91f5ca2d1baef52aa2add8808aa66bdd93e5314d2a22b8c1a00ca4bd62c3191bd2695ec7de6c3af1cf403015ab605f2a7add5f83080e6c3b2e5a1a7eb2dfc16651f78d44ebee8841150ef890832b450a8c1a6f58f7de2872fa249ca539cdfe1b2b45f90819c517c945b389a86bde189766ca30085d6d75f96e5f5ed6f50473e251f98f245fb77bc19df873f274b9ed97cd004bb47e9cc05e86f8dba730d3f1b5327ccf0e4e129549b59de3d9bcd02ff3ffc2ff6f57bfe49c366c126115fd26b0ec2843ed58ad9750aafb4d15a7b5b74df120edef9c5543650b2e28471093e16978e1a1183d1512db2b695c9f2be97133b6134df3cf60856b0e63f1552304b495f9ac95acbb3f9e8b38eb042cf0e2e2521d865e6760908ed83d70d803c115b6bfda8d2c56ff2afcbfe439144fa7dd3679bf39e1a1328959ac6c1fc03d8be29884f5fbbbcfc32f0ef2fb619b4fb9a8efdcbf414bb5388e02fed7008aaaf73cfdcbfdb5465a5a72be12f1357331a201d61576a341423edc8cf318368e8e8320a45a7ac1ae2374390cadb13ded643b29cf117bee301a03cef4aa74d079a7426b724c0d38f93b7e600ff8faba9b5be12fdc961965a7c6444afaa4c27487eeeae4574c10015093f0c6b1a925a616c99bd778f4daf6b7b67391e14ecff9f26efb4700872730b96d06be147c3f52f0267930fe3f6f2ac95d1e2a21bee39309d370da2aa27ef693a3ae34d09941ceb0f3279a2935e1888d3e746176e930dc9d50c79554ab8a2b6aa264c992dc863d9f7409b847b74f5952f9ff84fc83de80231264453b3b0de52b26c21c6951abe1d6d69bf28142edafdcc0d4ed956b53e0bcad623bf8a3b56076060e6aae6d0ec5aeee2e81f1c8bc6f1b70e289dc327032bf44e10450698a35d732aec14edd606c8cfd60c402de7f439857838e5eed816f01d0690ce3004267a84bce1b0f38e86d57d81eb9af7d14e2f63d62c7832a34629b7a2f22a054e87d03282ec6a1769252bb884169c34c1bd353a3cd6b41aa914c951afc21ad65ce38945f2e8af91a9765a81b200d8cfaa7abe611ab6263b3e797aa53f220687909613e558f4c52a61a330dfc518c03986e719872988e9c533bb5f128cfc91ba368f4d68271db9896491c79794d79deabc71bae061bcf68602460da21dff27d022f720ba0fbb94500d41b06fe117c3e218852a529e3d8ecc2b45cb55f19e935250ded95d8f517a4d7c92516f6c74a77594ad823d2ba77d5225323d266103269076de53181a9a6f365cf1de7764247bda1a9d43b5128ab5d70eaa07983f9b07340a29fc244d6f0937bb24aed778d2b3bfa48aa71eec83d23abaaccc10d5e68184247b0e347ca984751d85274c2fa37baf1d04cb3781725e8a2d11a7c8dc70f1ced68fd4eb429c11749dab66771721524ce06735553b94bdb6f7cb3567740ee705e23637f0a5574ad6371ebaa15c147b8d0b0f162f1644f43d1fa3204c3ed617377dd56044e24b31cf84cbcbc4bd8b1334ca2f9afd36da3716c7c8fdfce7ab51192acb63dcaf0f05df2a7148a415bc6ef8f05b4b1ebdb6eb007a4706516a9f957a69ccbfd99a4bb047fc55b6fb329f80046b21580706a175c5a329ee1a8bdf23a6ba20e9c0c4461cb227087ad4b919f8a5955f9b0b124e7607e4e417e95c9d4ddaa0711187e5003d6958716e9a280f4353143e008d0045627205585af36bb85b241e342e11fec4540a5c7a072a5a20e943b2565dac3e0287933288719cbc565c67b0d98ed410495573fe4b4edfcd7ccadd6647ecffb57d6577669bc293616041aa6a554f1a7fc9250dbeefd0ef971f6dd51b0e99fa886770f3ae1d7f9920d339eba5665fb4f8847607cca7c66551a46887f7734959eff3aebe29b272e641f185a9e3679b17c77e7df9c63011e1b6d157be804f6c0bbf3b649d7f7ea98e76399aeb0472ab456d86392765032b32748affc99558d51aa398e730899b20005e85fd8971c8db7af1072fd899a5c8c38ba10fa243ae63b3ba6a919657d778a428348e57e088d6294215348b48a52d0988c02f8d7dcf57144502125bb7cd601210fcb2b91e6aa557b3824b9912e7280daa7068d90ec9953873504d1d96823a1c9912134503369988a9ace9669fe95d3cdd6a361f4ea6c37df200a52b8653a6c1e493ccc1312f2f4b73b02ca35d5b107f643b92b52313555cf4d51ec6a7290e52081bb5fa2c683c76d6233685b3f031b5b24687f75e0213d6c455248850b3167ad32209ea8f6790620cc194650a7105eea16d66e2c55e192bf8fe7bd08e21ed6b02c6ab53ddf583091d2907fcaacb3a1e933a4d585ce5391ed3de3900ff6272fca0a2653886788e4a245b3ee88ac924da1ebc2fd10dcda62e64381523259b317bd122d1876c01fbe6e4ac096845646c6d543a18f5732194307ec7fca9f4e554a9300bcd8c83547f75c61de74d8717b3cf755177274909628cee85f4a20f16422fd50ce8436500a68f7cddafbb08023e92609e25ff26fafa5ff6f984b7bdcc96ba849592477de87e930b121c8ce957472287896dcd2e26680df1c47a6f88599b128f9bdb493e99be903cd66b8480e1446844986ff260b961ba05e26306b0a8817759ea41fdb25bf7617a55478d56e72cd7acad2d4e67bfd67f495504779e379da311fd49a5c2d31ddd12114e0f65f1766d28c8eb28ce92d57b776d24cd7dc57472a77607a0f981521db35c914f691d513964ba7db3469395bfcffe1bfca1499ffbd7d7c0a195c1e5cf8e670aa9eb01ca4990a53c50aee08c139c6c67011d251a6a8709c90e73ffd6d9993f70dcf3ec85c83c77a01f37f2b9a397c84401f020fc4f027bc75c8e8adca83800cdb0affa74014b7b2a9438a04d71a860264caec0e26b139a2d3c585a3ffbd7cfb3f5ebf8caeddbbfe2a75f58422ddbcf162ec7da715c4cf8ed96f0e90cdca279a59ab95d21ad3e46d0a48a2da660ce94197beb21819ee268929c96042dc53c3d7762c883fe0c3f4aa10a127d362c89056a87f42b01e0ca7f6ffe97be3ee36e545c750d8b71719a7ad2770a4442e8060ee8020e23359d4b13428d2aefc4982ceb3b29ac651da938347cfe6e6668dd049240291f7947821f77ceb3132c24b6949d3d4410a1ba3ec8e410067791327d384c1efbf042ae0fbd86041786b8105d82a0100594e729368f24f06842fbd980a60faddeef6c64fc1436c04b48b9cadfef3b24c0c576bfa44540ac6d83da2d90e72ca41292f7cdc0eee138145a257fc811c72dc660f3e4dc88c079f8766de6cd5b7fb2004a33ff2f888b5bf18566042bf93ad8e727795d4d4fe9e3c88e3a5b85e3b18056c9d1667e2cf01a36009264eebe44c9522742892ca8b0904f9c95b62af8c611e9550c0b490e01735a5acca19f015ac5a7dda37f25d41d9ab5fb9cd48c191138f23386ccd32588440418cee285b08b8807e1a1075312abcaf980f911810aa9314600df7bcfde7be9eb8b6172aa8d1d80bc17ff7f6def109768644612a7578873521627899eb7db699e44b7b69957d1121db7acee44fbdc88e9b155c0c5a31efb5a0ff176dbb2ab65abd3b86158960854278b79c2821f38577ac5c3619b9afb0ae0f69b336c6b61e35c6b82a4300cfe4d069ed6998ffbf35082bc8ba2d3606af2d92f2e78449ad6e9987909d6d6ae8866b0e22346e00270e4678e554336f39772b242003db68c1039d92c65c51657fde622edd36e972667d348bc9fac94e3441c6197a4e0bb7b58fdbf2105e86479723b834a85f5c68a622943a93779f91cdf2c1901755dc05e08e8e59789193cef931e4d8ba90d2b12bdcf74c118682832d75197a277b22c37bcb52c2535dc023e13174a4f3f25b8fb62af9bcdfd1c5c7dbd3cde7fbece291dd8f7ab2bd0e6f6c667e7bc84188262f4d294dcf1339237efb44c8e3b4a4b9f467de9909362a77a744478d091efcb453749ea47142575a29bdecf3f1db7da936699cd087fee14ebccf2e0faac7a70c64f37ba766de49ed4864c53c538341aedcfce2743fe4e0c3e00a8b11e3d345141e54b025c3dde38a5a5955fcacbc612e9270c3d5a03162309c5ca17a0b77a23ae581102b3abf089f92d162eb7e9279fb3d89ed538db79b10d4693579a566a6b7c5fab34fcf8bb4f71ddfb981087245b9214596807961261ed402fc9712cb7cfe6d00eabd12e068917bf7325359f64a3e871a9cbaae203988f710418c3c1bd67bb60b2985262beb00ee407d42733669b255ff01ce772bebe1a38d64351186c0347f98102924cfa519e58da365638b1c32c6678fa4941fc6cdd1aeba9d55d393d01fcf30c1fb8a80ca2b9c8eb65e68ea9defae6dd5edc11d7d409ab9706bf1ee974238ca1d970a537bd02d9c142afdeb0a985239bdd53383269fb8fb609fcfa43d539aa4271ad974dd8080c74ad0abb01f620cff93863c2ed9228c32be386bcf58871ebc3cda3f9e424b72d3d26b2412c6bd7871c288ad55c2c3f08c1114a61fe0094937944a01f14449a360c5dc08f53ad7fb977bc81a32a04b08c6211cc9ca7f1beecf13467c8b77d0f4d8554cde37692b60307acf94a64e37f6dbdf1d67f2aca76a9c09f00d5da1b0ab813ac2b628272535fbff1ef658e40a8721f997016aaa2a23d8f95894366892446c781b5c8e813846f31995b147be0cd2bb2f280f415159eb0b9c1c1c78511b3cf7539a30902d2d9dc4cbaf1d4b2a4a7903977047d7e94de7c6642b3fc54c1671ea7a3573c2b9a9742dfa7bd8d947677558817a8b12d39a120ad6b60cb189a211180c5d1a09dcf78ff475f3cdb49eb8fa51e93a524cd3b95e5c0e8c6087ac1dac46b921d65fc458d0096fb21a7e7f912056256911b7959b4115ea9f6edf7e19cfde024e51fad4e21ebd064c752c649b44567e009698a0ac6ce722a92a7864ab1425bb88</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="随笔" scheme="https://legendgod.ml/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>一些回忆和想说的话</title>
    <link href="https://legendgod.ml/2022/05/27/something_bad/"/>
    <id>https://legendgod.ml/2022/05/27/something_bad/</id>
    <published>2022-05-27T12:59:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7c111a082684902a1f09733050ad5e3a6d3ab0af5948e6689840760876e57272">8cef0bfe5dbef7c0807e31fc24201994453d6958581aaef7b184c495cf24004f746901fa03a8a21411043fa06ca1352a306dbb6826cd51a48218a0fb0b2ff773be4e55cc25b0d11fe3ca9906b92ef9a4f22780b590cb6a03a14d40f963beeb1c258d56c7c3396a128945aa6c012f42607f1177fdcb1d68fb0e036279c138c027d4e488fa62e7a535d30e2f06a95b521fe2c83ef074daf1a3f431342b263b08f1005e68d5374efc4e99adb3d30e940c24460ad366bf0b8740f1c485d1debc8e0bed558140458b4cd7b70d40e05d5ecddf6d4b2255e0b150a93258a1a23bb38c7eadff9643f10ab3d0f46c80a5fa5b97621c185d91d046886d8d222d4b1647aa116cdda3e73e9c3aed83d1df4880493cee4ab46d896f863ca232f86a933d19980dcf473e14ae6710a2cae14230b704144367cc68e3bde4794d6b63c91eab3377c1fd9f055144d188be10d61666f510177c176e1cad2b16edc7aeb73833fac7db539bba9497ded7966e3b033f45f57cf80488074f7a2f52da8af3e7bb123949b90f21274bea7b319a045525e74270c490462b579e5e4b363ad3ce58873a47c84dc3a808afbd3a214288e83bd9b71e79e84ff063fd880e586a3a9d3986d54e6b66fc92e69d7067ebca980f2e0c914b8130474e3a9dd542566b87e2653aaa01cd05c47a377d5113b98431027103cb03700ca1e7f82341d5d144ae3bd818b6db90e389129f4535b93ee95da366572531c3b233187badbd506357502a59bd99b6601fdcb9b646acc48ac11c81c1105aa6c86c739a5c44491a380103722d69defd15143b760fa9b07703b592e6237f7cf7e7b6bdb73fde4d02add03072758cf2bb0e960f8b2b76249be744c00c7db86bda175953427d1246d6a240f8055318aa805c52b07156d948a8a839f56911efbbf3c1d48862c1cb46f246c746fe785130e6b8d1845e32b0c1f00a2ff4a771e103750a2f2d357e44cf515b3d0804a9cfdc4b9429bd699f3af69765c15193a37da903a999a45c4eb05e8b3dd8afee2c08508968e76b272f96460cde5773ee83c00336f88ad016b6ddc0c9240b4accf47d7a544aa81ebde06f078210a54b042d6a20547bb13c1658edce54aca631ceb0623899ec6716ef5e1db260006de873816dcbc994cd4dbaba46236650a6e24f20ffc773cb3df6e0b5135f010f853be10e258a59efbd3adc6fcc5f448a26b3714e574be7fc712dee85acc611a046b5b9123cdc241b3590422f2219922063098bce37ced7d0fff9f40c1657c920b2292f065f1aa54a504d71f54b7f775288eecf3866f8c0a2d76925f4a5356cb9890ca484b7d52fee93a77d9c6d1bcb8ef226b6d73bd33c7f82d6c31fc9720069befb1581d32b92b0dc0befe414bfd9087914b6b72551c50144ad297701ac11e17374a4caa113705c349321c909d9e96e49f7f1171bfecfe41f128d93f9b884924451f4e7b9e37a5849466c02a6a68e102de7382d2362ceb035f7ef958e8ebae9b7440501670a62562e80e768362d90b170b4e6487cd4646c9addd08bba39c5d9742f0943604745852efd7a33b22e261cbe5050ef18e4108cc25808d9337dbcd750e5743efe78dde528bec6f2bda42e84f2a50776278262bad2d507b2c559e5e3f25f829fb63e298656bda7ab4931f2a13675408b84e705402573c67f3a392a3e05f7807dee684d57471e9cc7f2574d428e7f9fe2f484ad5b17d97806358f269b74d099e3ef7a540c8809a4c1143135cae5fcbcd96cd1771ba02b2faa34c5cb8bb40d76536229c8498a64c9e029d1233a28dcc026360c52809247e624985460299f3c8130bda30cf2aabfea8a678562e1542d0a300adabe4497d00c66a111db83eefed41601ac7c8e73fed609978034f947b4bb3ad0ad3b82410cdcbaa0348b1b68c3a9b0592b16140efc34923d7cadf6d53016c80fb0b1a91a7a6970cc8873ec2b2cdb83ef77b6277f0328c8469de6d9b3984dd8f1cd4ea214ed127e5898a5d320190305f478f10fe2123a65ffa7c73b4646fdcbf95923fd904d49eb4d3cd1fefbeb83ca7a07eddeb58e722e80ea99f3631a864bb8c82b3d02c0dc76ad8337d5afb978fa5ff9b52209f21603a392556d2eb2c2785ca733f6a86dc0df1a91ebedc5e0db38844ff7cb31d8b5296bb86d2db2bb5e33a336aba83494981f6fb56213bab9a5dab7b79c81312801839a297cfd95060c5ba1ba62bd931578663a5f44f8935339104d4aaef1a107ca58b3c97f72b73d42bade0cd883c714a439436ff2e0533a5a7d2cd6d42302eb821ed143b7c99ae9748b4935bce610a1927f71067d4c78628043fdeeed5e0655096cea908cb0d1a778212ab5899f8fa72b0aa92913f970173c66f1f29a99e699d23613a7318c1080506120f6360b7eed94b51f3b341adb03aa3353ed74b6c538ca60715c3b492baac69f02d60c557e33b66765ff7a20d66fa99577f73e8446352d3f2d65f6e21bd2f28a6307dc74b19bc9ccd6f87262a4784261c49841d09c113c32d20c875c7f9db80bacdbcc239a389100195f8c5448d39801f8c714da6e9460d7038a67bed8d622a1593fa1b0bf5cfc3273cc64639034cea33d78efa9d61ee3612a63802e5a475d848444c5fd6445f7d28cd2297567f8f00ebb479e854eae22cdfc5aa3db3692f77a0695db022663231bb50be8549026d9db94d75eef0503938c7362231c1c126675416bd85628a0ec4ffbd309ddd743a446396412d4604ad4f664259245f709d45174fdab3aee51f2aa0457f214b8ad489c7bb18345e3a286f2f4a2b00c58bbe19d8c455242f0f3e1281e5a3064cbf5457e1afa1e8c550bf000a4b8760186f822a05f643ac2c4e3192dc4aed4e7237b9cdec0f458775f0ff4d31ac70edf987c31a3e28f1bb4f44cdde2e2645fa59529918ab49c4b1589e9c9fc4fba49affe2db6acd0bdbafd40c4c1c094012fb858248d97bdf0ff6e267574a98ff477722f7f832026bf549f3c5d5466f6da07fbf0b51a54d9d45e4846b688d428ecbfb06ff05349821463383d9eb57c1ca7a4b23461b855ba4383019f595e342ad74261f221c58d9a8671134457c8c292b52e8dcbb814c69e00ad69144945795156dc6cf30d2ef07b6d1ffa6862d10291a57154dcfba2d8afc7e78bced7052582471a968237fa2a95011ec7210f9bfe5c6b7a955c4e29d2af6e593c3f06eb8f0f4b7000a54ea2dc76ce9da1dc26512cfb72d734fb243306c62851cf2ef5e667043c3ef088c33a2921c8eb1f136e0bf0b421fb0431cee89590b7aad272be714bb3ec9213a94164d51417edd8d00fb414a82d00818f4ea5fd345a99c0ff015ee1182cd974628fd78e775d673938c54af5605201af53b528efd0039e45567c83ce74f256b1f3a1d6b67a365bbb9fc69ea749fd43d14c5d0e1e9720e32b7acf3c272b7102110c4e1585af0179b31fe99e53e9a55d135bb8972baf884dd247c4fea6ee3d3a5fb3d96721004f9034a332fb7c932c2f4119a03287b058a6766163015c520aaed3a53e08df36f738f2b49910df32a7ae7bde7273d56ce5531f9dca4b8653d21b9bc0ab3c3f43932ead47c95e7b8738530576bdef14405fa702a33d10e4c8c54744e5967b5c9923085413fa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="随笔" scheme="https://legendgod.ml/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>AT2369 [AGC013C] Ants on a Circle 多解法讨论</title>
    <link href="https://legendgod.ml/2022/04/29/at-solution-agc013c/"/>
    <id>https://legendgod.ml/2022/04/29/at-solution-agc013c/</id>
    <published>2022-04-29T08:01:00.000Z</published>
    <updated>2022-11-11T11:18:54.369Z</updated>
    
    <content type="html"><![CDATA[<h4 id="AT2369-AGC013C-Ants-on-a-Circle"><a href="#AT2369-AGC013C-Ants-on-a-Circle" class="headerlink" title="AT2369 [AGC013C] Ants on a Circle"></a><a href="https://www.luogu.com.cn/problem/AT2369">AT2369 [AGC013C] Ants on a Circle</a></h4><blockquote><p>应该是第二次做到这个题了，但是还是没有写出来。第一次没有看懂题意不应该是理由，倒数的几篇题解，省选退役了。。。</p></blockquote><p>首先如果不考虑编号，我们穿过和返回本质是一样的。</p><p>其次对于碰撞我们可以看成穿过之后编号进行了交换，那么我们就需要计算交换编号之后的情况。</p><ul><li>节点的相对顺序是不变的。</li><li>节点经过 $m$ 时间之后绝对位置是不变的。</li></ul><p>我们考虑计算每个点的编号，这样就可以不用考虑返回的情况。</p><hr><h3 id="tt-Solution-1"><a href="#tt-Solution-1" class="headerlink" title="$\tt Solution \ 1$"></a>$\tt Solution \ 1$</h3><p>考虑对于一个点，考虑与其相反的点和其碰撞的次数。</p><p>我们可以考虑到这个点和相反的所有点碰撞，可以看成两部分，一部分是 $k$ 倍的 $m$ 时间，还有剩余的时间。</p><p>直接使用二分即可。</p><p>考虑从位置 $x$ 走可以分成 $x + T$ 和 $x$ 部分进行计算贡献，这样计算周期就是经过 $0$ 的了，之后考虑 $v \equiv p \pmod m$，可以直接计算出周期和单独部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, T;</span><br><span class="line"><span class="keyword">int</span> l[maxn], sl, r[maxn], sr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, d;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn], ans[maxn], id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = (x % m + m) % m, tmp1 = (x - tmp) / m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">upper_bound</span>(r, r + sr, tmp) - r + tmp1 * sr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Q1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = (x % m + m) % m, tmp1 = (x - tmp) / m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">upper_bound</span>(l, l + sl, tmp) - l + tmp1 * sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m, T);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x;</span><br><span class="line">        <span class="built_in">r1</span>(x, op);</span><br><span class="line">        a[i] = &#123;op, x&#125;;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) r[sr ++] = x;</span><br><span class="line">        <span class="keyword">else</span> l[sl ++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        x[i] = a[i].d;</span><br><span class="line">        <span class="keyword">if</span>(a[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">            x[i] = (x[i] + T) % m;</span><br><span class="line">            id[i] = (i + <span class="built_in">Q1</span>(a[i].d + <span class="number">2</span> * T) - <span class="built_in">Q1</span>(a[i].d)) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x[i] = ((x[i] - T) % m + m) % m;</span><br><span class="line">            id[i] = (i - <span class="built_in">Q2</span>(a[i].d - <span class="number">1</span>) + <span class="built_in">Q2</span>(a[i].d - <span class="number">2</span> * T - <span class="number">1</span>)) % n;</span><br><span class="line">            id[i] = (id[i] + n) % n;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf(&quot;%d : %d\n&quot;, i, id[i]);</span></span><br><span class="line">        ans[id[i]] = x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="tt-Solution-2"><a href="#tt-Solution-2" class="headerlink" title="$\tt Solution\ 2$"></a>$\tt Solution\ 2$</h3><p>有一说一思路是一样的，有更好的实现方法。</p><p>可以先求出最终的的所有位置，之后求出平移了多少，之后平移回来。</p><p>我们考虑从 $0$ 从顺时针开始走给每个点钦定，那么如果有一个点逆时针走过了 $0$ 那么最终位置会向前移动一位，不然就是向后。</p><p>本质就是计算走了几圈。</p><blockquote><p>注意负数需要取下整的操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, T, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">del</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">r1</span>(n, m, T);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, op; <span class="built_in">r1</span>(x, op);</span><br><span class="line">        x += (op == <span class="number">1</span> ? T : -T);</span><br><span class="line">        del += (<span class="keyword">int</span>)<span class="built_in">floor</span>(<span class="number">1.0</span> * x / m);</span><br><span class="line">        ans[i] = ((x % m) + m) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    del = (del % n + n) % n;</span><br><span class="line">    <span class="built_in">sort</span>(ans, ans + n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[(i + del) % n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;AT2369-AGC013C-Ants-on-a-Circle&quot;&gt;&lt;a href=&quot;#AT2369-AGC013C-Ants-on-a-Circle&quot; class=&quot;headerlink&quot; title=&quot;AT2369 [AGC013C] Ants on a Cir</summary>
      
    
    
    
    <category term="AT题解" scheme="https://legendgod.ml/categories/AT%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="贪心" scheme="https://legendgod.ml/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>P7987 [USACO21DEC] Paired Up G 题解</title>
    <link href="https://legendgod.ml/2022/04/28/usaco-solution-202112-t3g/"/>
    <id>https://legendgod.ml/2022/04/28/usaco-solution-202112-t3g/</id>
    <published>2022-04-28T12:27:00.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P7987-USACO21DEC-Paired-Up-G"><a href="#P7987-USACO21DEC-Paired-Up-G" class="headerlink" title="P7987 [USACO21DEC] Paired Up G"></a><a href="https://www.luogu.com.cn/problem/P7987">P7987 [USACO21DEC] Paired Up G</a></h4><p>首先考虑我们匹配肯定是相邻匹配的，之后还有一种可能是间隔一个匹配的。</p><p>对于这样进行 $\tt Dp$ 设 $f(i, j)$ 其中 $j$ 是 $0&#x2F;1$ 表示 $1 \sim i$ 未匹配点的奇偶性。</p><p>考虑如下 $4$ 种类转移，设 <code>z = i &amp; 1</code>，$las$ 表示最大的 $x_i - x_{las} &gt; K$ 的位置。</p><ul><li><p>中间有一段是可以内部匹配的 $f(i, z) &#x3D; f(las, !z) + y_i$。</p></li><li><p>$x_i - x_{i - 1} \le K$ ，考虑让 $i, i - 1$ 匹配 $f(i, z) &#x3D; f(i - 1, z)$。</p></li><li><p>$x_{i + 1} - x_i \le K$，考虑让 $i, i + 1$ 匹配，那么匹配点的奇偶性改变 $f(i, !z) &#x3D; f(i - 1, !z)$。</p></li><li><p>$x_{i + 1} - x_i \le K$，考虑跳过这个位置，有 $f(i, !z) &#x3D; f(las, z) + y_i$。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> x[maxn], y[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>&amp; x,<span class="keyword">int</span> c)</span> </span>&#123; x = <span class="built_in">min</span>(x, c); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, T, op = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">r1</span>(T, n, m);</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">2</span>) op = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(x[i], y[i]), y[i] *= op;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ps</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(x[i] - x[ps + <span class="number">1</span>] &gt; m) ++ ps;</span><br><span class="line">        <span class="keyword">int</span> z = (i &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Min</span>(f[i][z], f[ps][!z] + y[i]);</span><br><span class="line">        <span class="keyword">if</span>(x[i] - x[i - <span class="number">1</span>] &lt;= m) <span class="built_in">Min</span>(f[i][z], f[i - <span class="number">1</span>][z]);</span><br><span class="line">        <span class="keyword">if</span>(x[i + <span class="number">1</span>] - x[i] &lt;= m) <span class="built_in">Min</span>(f[i][!z], f[i - <span class="number">1</span>][!z]);</span><br><span class="line">        <span class="keyword">if</span>(x[i + <span class="number">1</span>] - x[i - <span class="number">1</span>] &lt;= m) <span class="built_in">Min</span>(f[i][!z], f[ps][z] + y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = f[n][n &amp; <span class="number">1</span>] * op;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">T</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    r1(T);</span></span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">Solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;P7987-USACO21DEC-Paired-Up-G&quot;&gt;&lt;a href=&quot;#P7987-USACO21DEC-Paired-Up-G&quot; class=&quot;headerlink&quot; title=&quot;P7987 [USACO21DEC] Paired Up G&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="USACO题解" scheme="https://legendgod.ml/categories/USACO%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Dp" scheme="https://legendgod.ml/tags/Dp/"/>
    
  </entry>
  
  <entry>
    <title>P8099 [USACO22JAN] Minimizing Haybales P 题解</title>
    <link href="https://legendgod.ml/2022/04/27/usaco-solution-202201pt-t1/"/>
    <id>https://legendgod.ml/2022/04/27/usaco-solution-202201pt-t1/</id>
    <published>2022-04-27T13:18:00.000Z</published>
    <updated>2022-11-11T11:18:54.385Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P8099-USACO22JAN-Minimizing-Haybales-P"><a href="#P8099-USACO22JAN-Minimizing-Haybales-P" class="headerlink" title="P8099 [USACO22JAN] Minimizing Haybales P"></a><a href="https://www.luogu.com.cn/problem/P8099">P8099 [USACO22JAN] Minimizing Haybales P</a></h4><p>考虑交换操作会自然想到贪心，考虑贪心选择。</p><p>现在对于贪心有一个唯一的问题：是否存在 $i &lt; j, h_i &gt; h_j$ 在 $i$ 进行交换之后 $j$ 不能到达 $j$ 先手操作的最优位置。</p><p>考虑 $i$ 向左操作的过程，其可以经过的是 $[h_i - k, h_i + k]$ 的部分，$j$ 经过的是 $[h_j - k, h_j + k]$。</p><p>仔细想想确实也没有影响，那么我们可以得到一个贪心。</p><p>从左向右扫维护最小字典序的序列，之后二分到一个最大的可以移动的位置，之后再次二分找到最优位置，也就是使得后缀没有 $&lt; h_i$ 的位置。</p><p>我们使用平衡树上二分就可以解决这题。</p><blockquote><p>一开始我做的时候，我贪心证伪了 $\cdots$</p><p>这样显得我很呆 $\cdots$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, K;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[maxn], rs[maxn], mn[maxn], mx[maxn], vl[maxn], rd[maxn], sz[maxn], rt, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    mn[p] = <span class="built_in">min</span>(<span class="built_in">min</span>(mn[ls[p]], mn[rs[p]]), vl[p]);</span><br><span class="line">    mx[p] = <span class="built_in">max</span>(<span class="built_in">max</span>(mx[ls[p]], mx[rs[p]]), vl[p]);</span><br><span class="line">    sz[p] = sz[ls[p]] + sz[rs[p]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">news</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = ++ tot;</span><br><span class="line">    vl[x] = mn[x] = mx[x] = v, sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> rd[x] = <span class="built_in">rand</span>(), ls[x] = rs[x] = <span class="number">0</span>, x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span>(rd[x] &gt; rd[y]) <span class="keyword">return</span> rs[x] = <span class="built_in">merge</span>(rs[x], y), <span class="built_in">pushup</span>(x), x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ls[y] = <span class="built_in">merge</span>(x, ls[y]), <span class="built_in">pushup</span>(y), y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> x = y = <span class="number">0</span>, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">    <span class="keyword">if</span>(K &lt;= sz[ls[p]]) <span class="built_in">split</span>(ls[p], x, ls[y = p], K);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">split</span>(rs[p], rs[x = p], y, K - sz[ls[p]] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == ed) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">split</span>(rt, c, d, i), <span class="built_in">split</span>(c, b, c, i - <span class="number">1</span>), <span class="built_in">split</span>(b, a, b, ed - <span class="number">1</span>);</span><br><span class="line">    rt = <span class="built_in">merge</span>(a, <span class="built_in">merge</span>(c, <span class="built_in">merge</span>(b, d)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">print</span>(ls[x]), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, vl[x]), <span class="built_in">print</span>(rs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, K);</span><br><span class="line">    mn[<span class="number">0</span>] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> h, p, ln, a, <span class="built_in">tot</span>(<span class="number">0</span>); <span class="built_in">r1</span>(h);</span><br><span class="line">        p = rt = <span class="built_in">merge</span>(rt, <span class="built_in">news</span>(h));</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = rs[p];</span><br><span class="line">            <span class="keyword">if</span>(mx[r] - h &gt; K || h - mn[r] &gt; K) p = r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vl[p] - h &gt; K || h - vl[p] &gt; K) &#123; tot += sz[r]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> tot += sz[r] + <span class="number">1</span>, p = ls[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//        puts(&quot;XX&quot;);</span></span><br><span class="line">        ln = i - tot;</span><br><span class="line">        <span class="built_in">split</span>(rt, rt, a, ln), p = a, tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(mx[a] == h) &#123; rt = <span class="built_in">merge</span>(rt, a); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = ls[p];</span><br><span class="line">            <span class="keyword">if</span>(mx[l] &gt; h) p = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vl[p] &gt; h) &#123; tot += sz[l]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> tot += sz[l] + <span class="number">1</span>, p = rs[p];</span><br><span class="line">        &#125;</span><br><span class="line">        rt = <span class="built_in">merge</span>(rt, a), <span class="built_in">move</span>(i, ln + tot + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">T</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    r1(T);</span></span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">Solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;P8099-USACO22JAN-Minimizing-Haybales-P&quot;&gt;&lt;a href=&quot;#P8099-USACO22JAN-Minimizing-Haybales-P&quot; class=&quot;headerlink&quot; title=&quot;P8099 [USACO22JA</summary>
      
    
    
    
    <category term="USACO题解" scheme="https://legendgod.ml/categories/USACO%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="贪心" scheme="https://legendgod.ml/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="平衡树" scheme="https://legendgod.ml/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CF917E Upside Down 题解</title>
    <link href="https://legendgod.ml/2022/04/26/cf-solution-917e/"/>
    <id>https://legendgod.ml/2022/04/26/cf-solution-917e/</id>
    <published>2022-04-26T07:11:00.000Z</published>
    <updated>2022-11-11T11:18:54.377Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CF917E-Upside-Down"><a href="#CF917E-Upside-Down" class="headerlink" title="CF917E Upside Down"></a><a href="https://www.luogu.com.cn/problem/CF917E">CF917E Upside Down</a></h4><blockquote><p>比较有趣的一个题。</p></blockquote><p>对于 $i \to j$ 的路径我们很容易想到分成两部分进行计算：</p><ul><li>$i \to lca$</li><li>$lca \to j$</li><li>跨过 $lca$</li></ul><p>对于前面的部分我们建立 $\tt ac$ 自动机，之后本质上就是单点加区间查询，我们树状数组维护一下。</p><p>我们方便处理的是从 $lca \to i$ 的路径，那么我们考虑对于不方便的情况直接建立反串的 $\tt ac$ 自动机即可。</p><p>对于跨过的部分我们不妨考虑字符串的分界点为 $x$，那么左边就是 $[1, x]$ 右边是 $[x + 1, n]$。对于两边发现有一个端点是固定的，我们考虑根据这个进行计算。</p><p>我们先考虑找到一个合法的串，我们不妨只考虑 $[x + 1, n]$ 的情况另一种情况同理，贪心考虑可以知道这个串右端点是固定的，考虑两段从 $\tt lca$ 经过若干步走到字符串末尾的串设长度为 $a, b, a &lt; b$。因为末尾部分是相同的，所以 $a$ 是 $b$ 的 $\tt border$，那么我们贪心可以考虑选取尽可能长的串。</p><p>选取串我们可以考虑尽可能长的串，经过简单转换可以变成 $\tt lcp$ 尽量大的串，看到 $\tt lcp$ 会考虑使用后缀数组。具体来说我们二分 $\tt rank$ 之后求出最长的 $\tt lcp$ 这个我们可以通过倍增 $\tt hash$ 来解决。</p><p>对于两个串的匹配，假设两个串长度分别为 $a, b$ 字符串总长为 $n$。我们有 $a + b &#x3D; n$，根据字符串 $\tt border$ 的性质我们可以划分成 $O(\log n)$ 的等差数列，对于等差数列内部我们暴力进行匹配，本质上就是找 $ax+ by &#x3D; c$ 的自然数解，可以使用 $\tt exgcd$ 解决。</p><p>对于询问直接离线到点上即可。</p><p><strong>注意：</strong> 考虑 $lca \to u$ 的路径，我们需要保证不存在一个串穿过 $\tt lca$ 的情况被计算，所以减去贡献的点需要相对向下平移一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, Q, head[maxn], <span class="built_in">cnt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125;edg[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edg[++ cnt] = (Edge) &#123;v, head[u], w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> _s[maxn];</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>, mod2 = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">Hash</span>(<span class="keyword">int</span> x = <span class="number">0</span>,<span class="keyword">int</span> y = <span class="number">0</span>) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;&#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> + (<span class="keyword">const</span> Hash&amp; z) &#123; <span class="keyword">return</span> (Hash)&#123;(a + z.a) % mod1, (b + z.b) % mod2&#125;; &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> - (<span class="keyword">const</span> Hash&amp; z) &#123; <span class="keyword">return</span> (Hash)&#123;(a - z.a + mod1) % mod1, (b - z.b + mod2) % mod2&#125;; &#125;</span><br><span class="line">    Hash <span class="keyword">operator</span> * (<span class="keyword">const</span> Hash&amp; z) &#123; <span class="keyword">return</span> (Hash)&#123;<span class="number">1ll</span> * a * z.a % mod1, <span class="number">1ll</span> * b * z.b % mod2&#125;; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Hash&amp; z) &#123; <span class="built_in"><span class="keyword">return</span></span> (a == z.a) &amp;&amp; (b == z.b); &#125;</span><br><span class="line">&#125;pw[maxn], th[maxn];</span><br><span class="line"><span class="keyword">const</span> Hash base = (Hash)&#123;<span class="number">13331</span>, <span class="number">131</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">21</span>], cl[maxn], dep[maxn];</span><br><span class="line"><span class="function">Hash <span class="title">Thas</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> th[u] - th[lc] * pw[dep[u] - dep[lc]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    fa[p][<span class="number">0</span>] = pre, dep[p] = dep[pre] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">19</span>; ++ i) fa[p][i] = fa[fa[p][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[p];i;i = edg[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = edg[i].to; <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        cl[to] = edg[i].w, th[to] = th[p] * base + (Hash)&#123;cl[to], cl[to]&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(to, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">int</span> d = dep[u] - dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; -- i) <span class="keyword">if</span>((d &gt;&gt; i) &amp; <span class="number">1</span>) u = fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i], v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; -- i) <span class="keyword">if</span>((k &gt;&gt; i) &amp; <span class="number">1</span>) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[maxn][<span class="number">27</span>], fl[maxn], tot, pos[maxn];</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vc[maxn];</span><br><span class="line">    <span class="built_in">ACAM</span>(<span class="keyword">void</span>) : <span class="built_in">tot</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> m,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p][x]) tr[p][x] = ++ tot;</span><br><span class="line">            p = tr[p][x];</span><br><span class="line">        &#125;</span><br><span class="line">        pos[id] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dfn[maxn], edfn[maxn], dfntot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[p] = ++ dfntot;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v : vc[p]) <span class="built_in">dfs</span>(v);</span><br><span class="line">        edfn[p] = dfntot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i) <span class="keyword">if</span>(tr[<span class="number">1</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">1</span>][i]), fl[tr[<span class="number">1</span>][i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tr[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v, i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++ i) &#123;</span><br><span class="line">                v = tr[u][i];</span><br><span class="line">                <span class="keyword">if</span>(v) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v), fl[v] = tr[fl[u]][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> tr[u][i] = tr[fl[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++ i) vc[fl[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        dfntot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> c)</span> </span>&#123; <span class="built_in">assert</span>(p != <span class="number">0</span>); p = dfn[p]; <span class="keyword">for</span>(; p &lt;= tot; p += <span class="built_in">lowbit</span>(p)) t[p] += c;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="keyword">for</span>(; p &gt; <span class="number">0</span>; p -= <span class="built_in">lowbit</span>(p)) res += t[p]; <span class="keyword">return</span> res; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; x = pos[x]; <span class="keyword">return</span> <span class="built_in">ask</span>(edfn[x]) - <span class="built_in">ask</span>(dfn[x] - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;Ta[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// Arithmetic sequence</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arith</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, t, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KMP</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *bel, *nxt, *del, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        bel = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">2</span>] ();</span><br><span class="line">        nxt = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">2</span>] ();</span><br><span class="line">        del = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">2</span>] ();</span><br><span class="line">        n = m;</span><br><span class="line">        del[<span class="number">1</span>] = <span class="number">1</span>, bel[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; str[j + <span class="number">1</span>] != str[i]) j = nxt[j];</span><br><span class="line"><span class="comment">//            printf(&quot;j = %d\n&quot;, j);</span></span><br><span class="line">            <span class="keyword">if</span>(str[j + <span class="number">1</span>] == str[i]) ++ j;</span><br><span class="line">            del[i] = i - j, nxt[i] = j;</span><br><span class="line">            bel[i] = (del[i] == del[j] ? bel[j] : i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> len,Arith* ret, <span class="keyword">int</span>&amp; tot)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; p &gt; len; p = nxt[p]) ;</span><br><span class="line">        <span class="keyword">while</span>(p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = bel[p], t = p, d = del[p];</span><br><span class="line">            ret[++ tot] = &#123;s, t, d&#125;;</span><br><span class="line">            p = nxt[s];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SA</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a, *sa, *sa2, *rk, n, m;</span><br><span class="line">    Hash *h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) buc[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) buc[rk[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) sa[buc[rk[sa2[i]]] --] = sa2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> ln)</span> </span>&#123;</span><br><span class="line">        n = ln, m = <span class="number">26</span>;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>] ();</span><br><span class="line">        sa = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>] ();</span><br><span class="line">        sa2 = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>] ();</span><br><span class="line">        rk = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>] ();</span><br><span class="line">        h = <span class="keyword">new</span> Hash[n + <span class="number">2</span>] ();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = str[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, h[i] = h[i - <span class="number">1</span>] * base + (Hash)&#123;a[i], a[i]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) rk[i] = a[i], sa2[i] = i;</span><br><span class="line">        <span class="built_in">Sort</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - i + <span class="number">1</span>; j &lt;= n; ++ j) sa2[++ num] = j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span>(sa[j] &gt; i)</span><br><span class="line">                sa2[++ num] = sa[j] - i;</span><br><span class="line">            <span class="built_in">Sort</span>();</span><br><span class="line">            <span class="built_in">swap</span>(rk, sa2);</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            rk[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; ++ j)</span><br><span class="line">                rk[sa[j]] = (sa2[sa[j]] == sa2[sa[j - <span class="number">1</span>]] &amp;&amp; sa2[sa[j] + i] == sa2[sa[j - <span class="number">1</span>] + i]) ? num : ++ num;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            m = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Hash <span class="title">Has</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> u,<span class="keyword">int</span> lc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = sa[id], ln = n - x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(u == lc) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ln &gt;= dep[u] - dep[lc] &amp;&amp; <span class="built_in">Thas</span>(u, lc) == <span class="built_in">Has</span>(x, x + dep[u] - dep[lc] - <span class="number">1</span>)) <span class="keyword">return</span> dep[u] - dep[lc];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; -- i) <span class="keyword">if</span>(dep[u] - dep[lc] &gt; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            <span class="keyword">if</span>( (ln &lt; dep[fa[u][i]] - dep[lc]) || ( !(<span class="built_in">Thas</span>(fa[u][i], lc) == <span class="built_in">Has</span>(x, x + dep[fa[u][i]] - dep[lc] - <span class="number">1</span>)) ) ) &#123;</span><br><span class="line">                u = fa[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        u = fa[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dep[u] - dep[lc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> u,<span class="keyword">int</span> lc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">lcp</span>(mid, u, lc);</span><br><span class="line">        <span class="keyword">if</span>(L == n - sa[mid] + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(L == dep[u] - dep[lc]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a[sa[mid] + L] &lt; cl[<span class="built_in">Jump</span>(u, dep[u] - dep[lc] - L - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lc,KMP&amp; kp, Arith* ret, <span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, <span class="built_in">ans</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid, u, lc)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ans) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> p = n - sa[ans] + <span class="number">1</span>, ln = <span class="built_in">lcp</span>(ans, u, lc);</span><br><span class="line">        kp.<span class="built_in">Get</span>(p, ln, ret, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;s[<span class="number">2</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Quer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, opt, C, str;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Quer&gt; q[maxn];</span><br><span class="line"><span class="keyword">int</span> sstr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">int</span> num0, <span class="keyword">int</span> num1)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    assert(num0 != 0 &amp;&amp; num1 != 0);</span></span><br><span class="line">    Ta[<span class="number">0</span>].<span class="built_in">add</span>(num0, <span class="number">1</span>), Ta[<span class="number">1</span>].<span class="built_in">add</span>(num1, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> Quer&amp; v : q[p]) &#123;</span><br><span class="line">        ans[v.id] += v.C * Ta[v.opt].<span class="built_in">query</span>(v.str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[p];i;i = edg[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = edg[i].to; <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> c = edg[i].w;</span><br><span class="line">        <span class="built_in">dfs2</span>(to, p, Ta[<span class="number">0</span>].tr[num0][c], Ta[<span class="number">1</span>].tr[num1][c]);</span><br><span class="line">    &#125;</span><br><span class="line">    Ta[<span class="number">0</span>].<span class="built_in">add</span>(num0, - <span class="number">1</span>), Ta[<span class="number">1</span>].<span class="built_in">add</span>(num1, - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qadd</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> lc,<span class="keyword">int</span> c,<span class="keyword">int</span> id,<span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] - dep[lc] &lt; sstr[c]) <span class="keyword">return</span> ;</span><br><span class="line">    q[u].<span class="built_in">push_back</span>(&#123;id, op, <span class="number">1</span>, c&#125;);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">Jump</span>(u, dep[u] - dep[lc] - sstr[c] + <span class="number">1</span>);</span><br><span class="line">    q[x].<span class="built_in">push_back</span>(&#123;id, op, - <span class="number">1</span>, c&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Chain &#123;</span><br><span class="line">    Arith a1[<span class="number">65</span>], a2[<span class="number">65</span>];</span><br><span class="line">    <span class="keyword">int</span> n1, n2;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">        <span class="keyword">int</span> gc = <span class="built_in">exgcd</span>(b, a % b, x, y); <span class="keyword">long</span> <span class="keyword">long</span> z = x;</span><br><span class="line">        x = y, y = z - a / b * y;</span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> ua,<span class="keyword">int</span> ub,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, x1, y1, dx, dy, mx;</span><br><span class="line">        <span class="keyword">int</span> gd = <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="keyword">if</span>(c % gd != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x1 = c / gd * x, y1 = c / gd * y;</span><br><span class="line">        dx = b / gd, dy = a / gd, mx = x1 % dx;</span><br><span class="line">        <span class="keyword">if</span>(mx &lt; <span class="number">0</span>) mx += dx;</span><br><span class="line">        y1 += ((x1 - mx) / dx) * dy, x1 = mx;</span><br><span class="line">        <span class="keyword">if</span>(y1 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(y1 &gt; ub) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (y1 - ub - <span class="number">1</span>) / dy + <span class="number">1</span>;</span><br><span class="line">            y1 -= tmp * dy, x1 += tmp * dx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || y1 &lt; <span class="number">0</span> || x1 &gt; ua || y1 &gt; ub) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>((ua - x1) / dx + <span class="number">1</span>, y1 / dy + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(Arith&amp; x, Arith&amp; y,<span class="keyword">int</span> ln)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Calc</span>(x.d, y.d, (x.t - x.s) / x.d, (y.t - y.s) / y.d, ln - x.s - y.s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v,<span class="keyword">int</span> lc, <span class="keyword">int</span> id,<span class="keyword">int</span> qi)</span> </span>&#123;</span><br><span class="line">        s[<span class="number">1</span>][id].<span class="built_in">Solve</span>(u, lc, p[<span class="number">0</span>][id], a1, n1);</span><br><span class="line">        s[<span class="number">0</span>][id].<span class="built_in">Solve</span>(v, lc, p[<span class="number">1</span>][id], a2, n2);</span><br><span class="line"><span class="comment">//        assert(n1 &lt; 60 &amp;&amp; n2 &lt; 60);</span></span><br><span class="line">        <span class="keyword">int</span> ln = sstr[id];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= n1; ++ a) <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= n2; ++ b)</span><br><span class="line">        <span class="keyword">if</span>(a1[a].s + a2[b].s &lt;= ln &amp;&amp; a1[a].t + a2[b].t &gt;= ln)</span><br><span class="line">            ans[qi] += <span class="built_in">calc</span>(a1[a], a2[b], ln);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m, Q);</span><br><span class="line">    pw[<span class="number">0</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; maxn; ++ i) pw[i] = pw[i - <span class="number">1</span>] * base;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">r1</span>(u, v), <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, _s + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(u, v, _s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>), <span class="built_in">add</span>(v, u, _s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, _s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ln = <span class="built_in">strlen</span>(_s + <span class="number">1</span>);</span><br><span class="line">        sstr[i] = ln;</span><br><span class="line">        Ta[<span class="number">0</span>].<span class="built_in">Insert</span>(_s, ln, i);</span><br><span class="line">        p[<span class="number">0</span>][i].<span class="built_in">Insert</span>(_s, ln);</span><br><span class="line">        s[<span class="number">0</span>][i].<span class="built_in">Insert</span>(_s, ln);</span><br><span class="line">        <span class="built_in">reverse</span>(_s + <span class="number">1</span>, _s + ln + <span class="number">1</span>);</span><br><span class="line">        Ta[<span class="number">1</span>].<span class="built_in">Insert</span>(_s, ln, i);</span><br><span class="line">        p[<span class="number">1</span>][i].<span class="built_in">Insert</span>(_s, ln);</span><br><span class="line">        s[<span class="number">1</span>][i].<span class="built_in">Insert</span>(_s, ln);</span><br><span class="line">    &#125;</span><br><span class="line">    Ta[<span class="number">0</span>].<span class="built_in">build</span>(), Ta[<span class="number">1</span>].<span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">struct Quer &#123;</span></span><br><span class="line"><span class="comment">    int id, opt, C, str;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Q; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, c;</span><br><span class="line">        <span class="built_in">r1</span>(u, v, c);</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="built_in">Lca</span>(u, v);</span><br><span class="line">        <span class="built_in">qadd</span>(u, lc, c, i, <span class="number">1</span>), <span class="built_in">qadd</span>(v, lc, c, i, <span class="number">0</span>);</span><br><span class="line">        Chain::<span class="built_in">Solve</span>(u, v, lc, c, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for(i = 1; i &lt;= Q; ++ i) printf(&quot;%d : %lld\n&quot;, i, ans[i]);</span></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Q; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;CF917E-Upside-Down&quot;&gt;&lt;a href=&quot;#CF917E-Upside-Down&quot; class=&quot;headerlink&quot; title=&quot;CF917E Upside Down&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.com.c</summary>
      
    
    
    
    <category term="CF题解" scheme="https://legendgod.ml/categories/CF%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数论" scheme="https://legendgod.ml/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="字符串" scheme="https://legendgod.ml/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="后缀数组" scheme="https://legendgod.ml/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
    <category term="AC自动机" scheme="https://legendgod.ml/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>P5287 [HNOI2019]JOJO 题解</title>
    <link href="https://legendgod.ml/2022/04/25/lg-solution-5287/"/>
    <id>https://legendgod.ml/2022/04/25/lg-solution-5287/</id>
    <published>2022-04-25T00:20:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<h4 id="P5287-HNOI2019-JOJO"><a href="#P5287-HNOI2019-JOJO" class="headerlink" title="P5287 [HNOI2019]JOJO"></a><a href="https://www.luogu.com.cn/problem/P5287">P5287 [HNOI2019]JOJO</a></h4><ul><li>加入 $x$ 个字符 $c$，保证相邻加入操作 $c$ 不同。</li><li>查询每个前缀的 $\tt border$ 长度和。</li></ul><p>如果不看输入感觉没有什么优秀的做法，输入提示了 $x$ 个 $c$ 肯定和做法有关。</p><p>我们尝试计算加入 $c$ 的 $\tt border$，首先找到加入前串 $S$ 的 $\tt border$，之后如果后面恰好有 $\ge x$ 个 $c$ 说明是可以匹配的，如果没有说明这个不是 $\tt border$，考虑继续向前找当前 $\tt border$ 的 $\tt border$。</p><p>既然相邻操作 $c$ 是不同的，考虑将一次操作看成一个点，$S$ 的 $\tt border$ 的结尾肯定恰好是一个完整点，不然之后不可能跟上 $c$。考虑跳 $\tt border$ 后每次后面跟着的 $c$ 是逐渐变多的，考虑如果减少的话 $\tt border$ 是可以增长的。</p><p>然后对于一段都能匹配是一个等差数列求和。</p><p>我们考虑暴力跳 $\tt border$ 是不行的，考虑优化，我们如果 $\tt border$ 的长度 $\ge \frac{|S|}{2}$ 那么就会产生循环节，我们考虑对于相同的循环节我们只需要计算一个即可，对于 $&lt; \frac{|S|}{2}$ 的情况，我们暴力跳，这样我们跳 $\tt border$ 的次数就是 $O(\log n)$ 级别的。</p><blockquote><p>对于前一种情况，还有一种说法就是将串 $S$ 进行 $\tt border$ 的等差数列划分，这样的划分是 $O(\log |S|)$ 级别的。</p><p>将 $\tt SAM$ 上每个节点的 $\tt endpos$集合划分为若干等差序列，等差序列的总个数是 $O(n \sqrt n)$ 的。</p><ul><li>对于 $len &lt; \sqrt n$ 的集合，因为相同长度的 $len$ 集合是不交的，所以总个数是 $O(n \sqrt n)$。</li><li>对于 $len &gt; \sqrt n$ 的集合， 若有两个<strong>相邻</strong>的 $\tt edp$ 距离不超过 $\frac{len}{2}$ ，则距离必然为最小循环节。由此，只有 $&gt; \frac{len}{2}$ 的空位才能隔断某个等差数列，故每个点的等差数列个数至多是 $O(\frac{n}{len}) &#x3D; O(\sqrt n)$ 的。</li></ul><blockquote><p>这个最小循环节可以通过 $\tt border$ 理论得出。</p></blockquote></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pr;</span><br><span class="line"><span class="keyword">int</span> n, m, ans[maxn], ln[maxn], fl[maxn], fl1[maxn], <span class="built_in">ed</span>(<span class="number">0</span>), prs[maxn], go[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vc[maxn];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">pr a[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clc</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> (<span class="number">1ll</span> * (l + r) * (r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) % mod; &#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>*, <span class="keyword">int</span>&gt; st[maxn * <span class="number">6</span>];</span><br><span class="line">pr b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> b)</span> </span>&#123; st[++ ed] = &#123;&amp;a, a&#125;, a = b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Roll</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ed &gt; x) &#123;</span><br><span class="line">        *(st[ed].first) = st[ed].second;</span><br><span class="line">        -- ed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123; a = (a + b) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> c,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    if(p == 6) puts(&quot;yes&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> l = ++ ln[p];</span><br><span class="line">    <span class="built_in">Ins</span>(b[l].first, c), <span class="built_in">Ins</span>(b[l].second, x), <span class="built_in">Ins</span>(prs[l], prs[l - <span class="number">1</span>] + x);</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Add</span>(ans[p], <span class="built_in">clc</span>(<span class="number">0</span>, x - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> np = fl[l - <span class="number">1</span>], lim = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    if(p == 6) &#123;</span></span><br><span class="line"><span class="comment">//        for(int i = 1; i &lt;= l; ++ i) printf(&quot;(%c, %d) = %d\n&quot;, &#x27;a&#x27; + b[i].first - 1, b[i].second, fl[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(np &gt;= <span class="number">0</span> &amp;&amp; b[np + <span class="number">1</span>] != b[l]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[np + <span class="number">1</span>].first == b[l].first &amp;&amp; b[np + <span class="number">1</span>].second &gt;= lim &amp;&amp; lim &lt;= x) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(ans[p], <span class="built_in">clc</span>(prs[np] + lim, prs[np] + <span class="built_in">min</span>(x, b[np + <span class="number">1</span>].second)));</span><br><span class="line">            lim = <span class="built_in">min</span>(b[np + <span class="number">1</span>].second, x) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//            if(p == 7) printf(&quot;S : %d \n&quot;, ans[p]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(go[np + <span class="number">1</span>]) np = fl1[np + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> np = fl[np];</span><br><span class="line">    &#125; ++ np;</span><br><span class="line">    <span class="keyword">if</span>(np &amp;&amp; (l - np) * <span class="number">2</span> &lt;= l) <span class="built_in">Ins</span>(go[l], <span class="number">1</span>), <span class="built_in">Ins</span>(fl1[l], fl[l % (l - np) + l - np]);</span><br><span class="line">    <span class="keyword">if</span>(!np &amp;&amp; b[<span class="number">1</span>].first == c &amp;&amp; b[<span class="number">1</span>].second &lt;= x) ++ np;</span><br><span class="line">    <span class="keyword">if</span>(np) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[np].second &gt;= lim &amp;&amp; lim &lt;= x) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(ans[p], <span class="built_in">clc</span>(prs[np - <span class="number">1</span>] + lim, prs[np - <span class="number">1</span>] + <span class="built_in">min</span>(b[np].second, x)));</span><br><span class="line">            lim = <span class="built_in">min</span>(b[np].second, x) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(np == <span class="number">1</span> &amp;&amp; lim &lt;= x) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(ans[p], <span class="number">1ll</span> * prs[np] * (x - lim + <span class="number">1</span>));</span><br><span class="line">            lim = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if(p == 6) printf(&quot;np = %d\n&quot;, np);</span></span><br><span class="line">    <span class="built_in">Ins</span>(fl[l], np);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = ed;</span><br><span class="line">    <span class="keyword">if</span>(vis[p]) <span class="built_in">Insert</span>(p, a[p].first, a[p].second);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v : vc[p]) &#123;</span><br><span class="line">        ln[v] = ln[p], ans[v] = ans[p];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Roll</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n);</span><br><span class="line">    fl[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt, x;</span><br><span class="line">        <span class="built_in">r1</span>(opt, x);</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>) &#123; vc[x].<span class="built_in">emplace_back</span>(i); <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        a[i] = &#123; s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, x &#125;, vis[i] = <span class="number">1</span>;</span><br><span class="line">        vc[i - <span class="number">1</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;P5287-HNOI2019-JOJO&quot;&gt;&lt;a href=&quot;#P5287-HNOI2019-JOJO&quot; class=&quot;headerlink&quot; title=&quot;P5287 [HNOI2019]JOJO&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.c</summary>
      
    
    
    
    <category term="洛谷题解" scheme="https://legendgod.ml/categories/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="字符串" scheme="https://legendgod.ml/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="border" scheme="https://legendgod.ml/tags/border/"/>
    
  </entry>
  
  <entry>
    <title>CF700E Cool Slogans 题解</title>
    <link href="https://legendgod.ml/2022/04/24/cf-solution-700e/"/>
    <id>https://legendgod.ml/2022/04/24/cf-solution-700e/</id>
    <published>2022-04-24T11:34:00.000Z</published>
    <updated>2022-11-11T11:18:54.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CF700E-Cool-Slogans"><a href="#CF700E-Cool-Slogans" class="headerlink" title="CF700E Cool Slogans"></a><a href="https://www.luogu.com.cn/problem/CF700E">CF700E Cool Slogans</a></h4><p>首先子串变成 $\tt SAM$，我们考虑出现两次不妨考虑在区间 $[l, r]$ 那么我们的串肯定也是 $[l, r]$ 多了肯定是不优的。</p><p>然后对于 $s_i, s_{i - 1}$ 可以发现 $s_{i - 1}$ 是顶着 $s_i$ 的左右侧的，我们可以随便钦定一个进行考虑，不妨考虑 $s_{i - 1}$ 是 $s_{i}$ 的后缀。</p><p>考虑后缀自动机上 $x, y$ 其中 $y$ 是 $x$ 的祖先。如何描述 $x$ 中出现了两次 $y$。</p><p>我们明确 $\tt endpos$ 集合在 $\tt parent$ 树上就是子树，对于一条链根据定义有上边串是下面串的后缀，所以肯定出现一次的。</p><p>我们只需要考虑另外一个点的情况，不妨考虑 $x$ 长度为 $len(x)$，可以发现如果 $y$ 的另外结束节点是在 $[pos(x) - len(x) + len(y), pos(x) - 1]$ 那么肯定是合法的。</p><p>我们可以使用经典套路线段树合并来查询。</p><p>考虑如何计算答案，如果上述 $x, y$ 是合法的我们考虑设 $f(x)$ 表示以 $x$ 结尾的答案。</p><p>但是问题来了，我们记录的都是最长串这个能代表当前集合吗？</p><p>先明确对于一个 $y$ 其使用最长串的限制是最严格的，因为 $\tt endpos$ 集合是相同的，我们贪心接纳尽可能多的子串所以选择最长的 $y$。</p><p>同样对于 $x$ 因为 $\tt endpos$ 集合是相同的，所以我们选择哪个点对于之后的匹配都是没有影响的，所以选择可能性最大的。</p><p>之后考虑进行 $\tt Dp$，设 $f(i)$ 表示点 $i$ 的答案，我们每次肯定尽量匹配短的，所以能匹配就匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> rt[maxn], <span class="built_in">itot</span>(<span class="number">0</span>), t[maxm], lson[maxm], rson[maxm];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls lson[p]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs rson[p]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> pr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++ itot;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= mid) ls = <span class="built_in">Insert</span>(lson[pr], l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> rs = <span class="built_in">Insert</span>(rson[pr], mid + <span class="number">1</span>, r, pos);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!u || !v) <span class="keyword">return</span> u | v;</span><br><span class="line">    <span class="keyword">int</span> op = ++ itot;</span><br><span class="line">    lson[op] = <span class="built_in">merge</span>(lson[u], lson[v]);</span><br><span class="line">    rson[op] = <span class="built_in">merge</span>(rson[u], rson[v]);</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= mid) res |= <span class="built_in">Ask</span>(ls, l, mid, ll, rr);</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; rr) res |= <span class="built_in">Ask</span>(rs, mid + <span class="number">1</span>, r, ll, rr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch[<span class="number">26</span>], fa, ln;</span><br><span class="line">&#125;d[maxn];</span><br><span class="line"><span class="keyword">int</span> pos[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">las</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">tot</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = las, np = las = ++ tot;</span><br><span class="line">    pos[np] = id, d[np].ln = d[p].ln + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; p &amp;&amp; !d[p].ch[c]; p = d[p].fa) d[p].ch[c] = np;</span><br><span class="line">    <span class="keyword">if</span>(!p) d[np].fa = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = d[p].ch[c];</span><br><span class="line">        <span class="keyword">if</span>(d[q].ln == d[p].ln + <span class="number">1</span>) d[np].fa = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nq = ++ tot; d[nq] = d[q], pos[nq] = pos[q];</span><br><span class="line">            d[nq].ln = d[p].ln + <span class="number">1</span>;</span><br><span class="line">            d[q].fa = d[np].fa = nq;</span><br><span class="line">            <span class="keyword">for</span>(; p &amp;&amp; d[p].ch[c] == q; p = d[p].fa) d[p].ch[c] = nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buc[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn], g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">Insert</span>(s[i] - <span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        p = d[p].ch[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        rt[p] = <span class="built_in">Insert</span>(<span class="number">0</span>, <span class="number">1</span>, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= tot; ++ i) ++ buc[d[i].ln];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) buc[i] += buc[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= tot; ++ i) b[buc[d[i].ln] --] = i;</span><br><span class="line"><span class="comment">//    for(i = 1; i &lt;= tot; ++ i) printf(&quot;%d : %d\n&quot;, i, pos[b[i]]);</span></span><br><span class="line">    <span class="keyword">for</span>(i = tot; i &gt; <span class="number">1</span>; -- i) rt[d[b[i]].fa] = <span class="built_in">merge</span>(rt[d[b[i]].fa], rt[b[i]]);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= tot; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = b[i];</span><br><span class="line">        <span class="keyword">if</span>(d[x].fa == <span class="number">1</span>) &#123; f[x] = <span class="number">1</span>, g[x] = x; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="comment">//        printf(&quot;(%d, %d)\n&quot;, pos[x] - d[x].ln + d[d[x].fa].ln, pos[x] - 1);</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Ask</span>(rt[g[d[x].fa]], <span class="number">1</span>, n, pos[x] - d[x].ln + d[g[d[x].fa]].ln, pos[x] - <span class="number">1</span>))</span><br><span class="line">            f[x] = f[d[x].fa] + <span class="number">1</span>, g[x] = x;</span><br><span class="line">        <span class="keyword">else</span> f[x] = f[d[x].fa], g[x] = g[d[x].fa];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;CF700E-Cool-Slogans&quot;&gt;&lt;a href=&quot;#CF700E-Cool-Slogans&quot; class=&quot;headerlink&quot; title=&quot;CF700E Cool Slogans&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.co</summary>
      
    
    
    
    <category term="CF题解" scheme="https://legendgod.ml/categories/CF%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="后缀自动机" scheme="https://legendgod.ml/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>数学回忆1</title>
    <link href="https://legendgod.ml/2022/04/22/remind-math1/"/>
    <id>https://legendgod.ml/2022/04/22/remind-math1/</id>
    <published>2022-04-22T13:29:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加乘原理"><a href="#加乘原理" class="headerlink" title="加乘原理"></a>加乘原理</h3><p>对于给定的集合 $S$ 对于其中满足某一性质 $P$ 的元素 $x$ 求和 $f(x)$ 即求出：</p><p>$$<br>\sum_{x \in S} f(x) [P(x)]<br>$$</p><p> 将 $S$ 称为<strong>组合类</strong>，$x$ 称为<strong>组合对象</strong>，$f$ 称为<strong>权值函数</strong>。</p><ul><li><h4 id="color-blue-Delta-构造双射"><a href="#color-blue-Delta-构造双射" class="headerlink" title="$\color{blue}\Delta$ 构造双射"></a>$\color{blue}\Delta$ 构造双射</h4></li></ul><ol><li>不同的两个组合类中的组合对象可以一一对应，这样对于两个组合类进行计数是等价的。</li><li>另一种情况是同一组合类中的组合对象可以建立对应关系 ( 或多个为一组 )，我们只需要对于每组中的一个进行计数，再乘上组的大小。</li></ol><ul><li><h4 id="color-blue-Delta-加法原理"><a href="#color-blue-Delta-加法原理" class="headerlink" title="$\color{blue}\Delta$ 加法原理"></a>$\color{blue}\Delta$ <strong>加法原理</strong></h4></li></ul><p>对 $S$ 中的所有元素求和 $f(x)$ 等价于将 $S$ 划分成若干个集合 $S_i$ 分别求和再相加：</p><p>$$<br>\sum_{x \in S} f(x) &#x3D; \sum_{i &#x3D; 1} ^ m (\sum_{x \in S_i} f(x))<br>$$</p><ul><li><h4 id="color-blue-Delta-乘法原理"><a href="#color-blue-Delta-乘法原理" class="headerlink" title="$\color{blue}\Delta$ 乘法原理"></a>$\color{blue}\Delta$ <strong>乘法原理</strong></h4></li></ul><p>将 $S$ 拆分成 $S_i$ 的笛卡尔积， $S$ 中元素的权值 $f(x)$ 等于其拆分出的各 $f_i(x_i)$ 只积，则对 $S$ 中的所有元素求和 $f(x)$ 等价于对于每个 $S_i$ 进行 $f_i(x_i)$ 求和之后相乘。</p><p>$$<br>\sum_{x \in S} f(x) &#x3D; \prod_{i &#x3D; 1} ^ m (\sum_{x_i \in S_i} f_i(x_i))<br>$$</p><p>我们除了可以交换 $\prod, \sum$ 我们还可以交换多个 $\sum$：</p><p>$$<br>\sum_{x \in A} \sum_{y \in B} f(x, y) &#x3D; \sum_{y \in B} \sum_{x \in A} f(x, y)<br>$$</p><p>这个常在 $B$ 受到 $x$ 的限制时的组合计数。</p><blockquote><p>求 $n$ 原正整数组 $(x_1, \cdots, x_n)$ 的数量，满足：</p><ul><li>$x_i \le a_i$</li><li>$x_i$ 互不相同</li></ul></blockquote><p>设 $S &#x3D; [a_i], f(x_1, \cdots, x_n) &#x3D; [x1 \ne x_2] \cdots [x_1 \ne x_n] \cdots [x_{n -1} \ne x_n]$。</p><p>那么本质就是对于 $\sum_{x_1 \in S_1, x_2 \in S_2 \cdots} f(x1, \cdots, x_n)$。</p><p>设 $f(x_1, \cdots, x_{i - 1} | x_i) &#x3D; [x_i \ne x_1] \cdots [x_i \ne x_{i - 1}]$。</p><p>那么原式可以变成：</p><p>$$<br>\sum_{x_1 \in S1} \sum_{x_2 \in S_2} f(x_1 | x_2) \cdots \sum_{x_n \in S_n} f(x_1, \cdots, x_{n - 1} | x_n)<br>$$</p><p>显然 $x_i$ 受到了前面权值的限制，我们通过交换求和符号使得 $a_i \le a_{i + 1}$ 那么 $x_{i + 1}$ 的所有限制就是可以被描述出来的，对于 $x_i$ 恰好有 $a_i - i + 1$ 种方案：</p><p>$$<br>\prod_{i &#x3D; 1} ^ m (\sum_{x_i \in S_i} f_i(x_i)) &#x3D; \prod_{i &#x3D; 1} ^ m (a_i - i + 1)<br>$$</p><blockquote><p><a href="https://www.luogu.com.cn/problem/AT3956">AT3956 [AGC023E] Inversions</a></p></blockquote><p>对于逆序对合并计算是比较复杂的，更何况加上 $P_i \le A_i$ 的限制，我们考虑对于 $i &lt; j, P_i &gt; P_j$ 的所有贡献。</p><p>$i &lt; j, P_i &gt; P_j$ 在前一例题的基础上我们只是多钦定了两个数的大小关系，对于 $A_i &lt; A_j$ 我们可以看成 $A_j &#x3D; A_i$ 的情况。</p><p>发现单独的方案限制很难描述，既然是 $A_j &#x3D; A_i$ 而且是互不相同我们那么逆序的方案就是总方案的 $\frac{1}{2}$。</p><p>对于 $i &lt; j, A_i &gt; A_j$ 的情况我们发现顺序对是很好求的，我们使用总方案减去顺序对方案。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P7140">P7140 [THUPC2021 初赛] 区间矩阵乘法</a></p></blockquote><p>看成矩阵 $A \times B$ 的形式，有 $\sum_{i} \sum_j \sum_k A(i, k) \times B(k, j)$。</p><p>考虑将 $k$ 移到最前面，对于 $A$ 就是列和，$B$ 就是行和。</p><p>我们有 $\sum_k (\sum_i A(i, k))(\sum_{j} B(k, j))$ 。</p><p>发现题目保证合法，意味着 $p + d^2 \le n$ 所以 $d$ 是 $O(\sqrt n)$ 级别的。</p><blockquote><ul><li>求给定的长度为 $n$ 的序列所有区间异或和的和。</li><li>求给定的大小为 $n$ 的集合所有子集异或和的和。</li></ul></blockquote><p>枚举每一位。</p><ul><li>区间异或和之和：对于位置 $r$ 只需要记录左边有多少个和当前值不同的。</li><li>子集异或和之和：明显子集个数太多信息不能保存，考虑构造双射，对于一个集合我们只关心其 $1$ 的个数。不妨考虑有 $x$ 个 $1$，对于任意位置选取和不选取是只是改变奇偶性，对于每个位置是独立的，所以奇和偶的方案是相同的。所以方案数是 $2^{n - 1}$。</li></ul><blockquote><p>给定一棵包含 $n$ 个结点的外向树，求其拓扑排序的个数。</p></blockquote><p>可以变成有根数，考虑对于节点 $i$ 其必须在其所有子树的节点前面。</p><p>对于所有排列，$i$ 最先出现的概率是 $\frac{1}{siz_i}$，对于每个节点都是不会相互影响的，因为要么是无关要么是父亲已经出现过了，所以方案数是 $\frac{n!}{\prod siz_i}$。</p><p>这里启发了我们我们不一定是考虑同时出现在 <code>queue</code> 中的点数可以任意排列，可以转而考虑每个点的限制，或者每个点限制了什么。</p><blockquote><p>给定 $n$ 个正整数 $d_{1, \cdots, n}$，求有多少个数列 $a_{1 \cdots, n}$ 满足：</p><ul><li>$a_i | d_i$</li><li>$\prod_{i}a_i \le \prod_{i} \frac{d_i}{a_i}$</li></ul></blockquote><p>发现直接进行计算不好处理限制，先想构造双射。</p><p>对于限制 $1$ 如果 $a_i^2 \ne d_i$ 对于一个 $a_i$ 显然可以对应一个唯一的 $\frac{d_i}{a_i}$。换言之就是对于一个满足条件的肯定可以映射到一个不满足条件的。总方案数就是 $d$ 的因子个数之积。</p><p>之后考虑 $\prod a_i &#x3D; \prod \frac{d_i}{a_i}$ 的情况。</p><p>移项，之后考虑每个质因子的出现次数是固定的，对于每个质因子分别进行背包。</p><h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><ul><li><h4 id="color-blue-Delta-tt-lucas-定理"><a href="#color-blue-Delta-tt-lucas-定理" class="headerlink" title="$\color{blue}\Delta$ $\tt lucas$ 定理"></a>$\color{blue}\Delta$ $\tt lucas$ 定理</h4></li></ul><p>设 $n, m$ 的 $p$ 进制为 $a_k\dots a_0, b_k \dots b_0$ 那么</p><p>$$<br>\binom{n}{m} \equiv \prod_{i &#x3D; 0} ^ k \binom{a_i}{b_i} \pmod p<br>$$</p><p>其中 $p$ 是质数，$n, m$ 是自然数。</p><p><strong>命题</strong>：$\binom{n + m}{n} \equiv 0 \pmod p$ 当且仅当 $n, m$ 的加法在 $p$ 进制下进位。</p><blockquote><p>根据上述定理可以知道如果 $a_i &lt; b_i$ 就去世了，显然如果 $a + b$ 进位了那么剩下的部分肯定是小于 $a, b$ 的。</p></blockquote><ul><li><h4 id="color-blue-Delta-Kummer-定理"><a href="#color-blue-Delta-Kummer-定理" class="headerlink" title="$\color{blue}\Delta$ Kummer 定理"></a>$\color{blue}\Delta$ Kummer 定理</h4></li></ul><p>$\dfrac{(n + m)!}{n! m!}$ 中质因子 $p$ 的次数恰好为 $n + m$ 计算过程中在 $p$ 进制小进位的个数。</p><ul><li><h4 id="color-blue-Delta-扩展-tt-lucas"><a href="#color-blue-Delta-扩展-tt-lucas" class="headerlink" title="$\color{blue}\Delta$ 扩展 $\tt lucas$"></a>$\color{blue}\Delta$ 扩展 $\tt lucas$</h4></li></ul><p>对于 $\dbinom{n}{m} &#x3D; \dfrac{n!}{m!(n - m)!}$ ，考虑分成是 $p$ 的倍数和不是 $p$ 的倍数两部分进行计算。</p><p>对于 $p$ 拆成 $\prod_i p_i^{a_i}$ 其中 $p_i$ 是质数，之后 $\tt CRT$ 回去。</p><p>不妨考虑 $n!, m!,(n - m)!$  中 $p_i$ 的因子分别为 $u, v, w$。</p><p>那么有 $\dbinom{n}{m} &#x3D; \dfrac{\dfrac{n!}{p_i^u}}{\dfrac{m!}{p_i^v}\dfrac{(n - m)!}{p_i^w}} \times p_i^{u - v - w}$。</p><p>对于 $u$ 的计算是容易的 $u &#x3D; \sum_{i &#x3D; 1} \dfrac{a_i}{p_i^i}$。</p><p>可以发现 $a! &#x3D; p_i^{\frac{a}{p_i}} \times \frac{a}{p_i}! \times \prod_{i &#x3D; 1, i \not \equiv 0 \pmod {p_i}} i$ 后面是一个周期函数可以预处理 $O(1)$ 计算。</p><p>左边的阶乘继续递归。</p><ul><li><h4 id="color-blue-Delta-组合数比大小"><a href="#color-blue-Delta-组合数比大小" class="headerlink" title="$\color{blue}\Delta$ 组合数比大小"></a>$\color{blue}\Delta$ 组合数比大小</h4></li></ul><p>给定 $\dbinom{a}{b}, \dbinom{c}{d}$ 比较大小，直接取对数。</p><ul><li><h4 id="color-blue-Delta-组合数前缀和"><a href="#color-blue-Delta-组合数前缀和" class="headerlink" title="$\color{blue}\Delta$ 组合数前缀和"></a>$\color{blue}\Delta$ 组合数前缀和</h4></li></ul><p>有 $q$ 组询问，每次给定 $n, m$ 求出 $\sum_{i &#x3D; 0} ^ m \dbinom{n}{i}$。</p><p>考虑使用莫队，设答案为 $f(n, m)$ 我们有 $f(n, m + 1) &#x3D; f(n, m) + \binom{n}{m + 1}$，$f(n + 1, m) &#x3D; 2f(n, m) - \binom{n}{m}$。</p><blockquote><p><a href="https://www.cnblogs.com/zwfymqz/p/9751173.html">别人的代码</a></p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P3726">[AHOI 2017 &#x2F; HNOI 2017] 抛硬币</a></p></blockquote><p>考虑对于 $a &#x3D; b$ 的情况对于甲胜和乙胜的情况是双射。</p><p>只要算出平局的数量即可。</p><p>对于 $a &gt; b$ 的情况，可能会出现反转和之前都是甲胜的情况。</p><p>考虑甲正面朝上 $i$ 次，乙 $j$ 次，我们有 $i &gt; j, a - i &gt; b - j$ 得到 $i - j \ge 1, a - b - 1 \ge i - j$。</p><p>考虑计数 $\dfrac{2^{a + b} + \sum_{u &#x3D; 0} ^ b \sum_{v &#x3D; 1} ^ {a - b - 1} \binom{b}{u}\binom{a}{u + v}}{2}$。</p><blockquote><p>$j, i - j$。</p></blockquote><p>后面部分是个范德蒙德卷积等于 $\binom{a + b}{b + v}$。</p><p>如果 $a &#x3D; b$ 的话需要特判。</p><blockquote><p>求有多少组 $a_1, \cdots, a_k$ 满足：</p><ul><li>$a_i \le x_i$</li><li>$\binom{\sum a_i}{a_1, \cdots, a_k}$ 是奇数</li></ul></blockquote><p>考虑 $\tt lucas$ 也就是不存在 $2$ 的倍数。</p><p>首先考虑 $\binom{\sum a_i}{a_1, \cdots, a_k}$ 是多项式系数，先转化 $\binom{\sum a_i}{a_1, \cdots, a_k} &#x3D; \prod \binom{a_i + \cdots + a_k}{a_i}$。</p><p>也就是任意 $a_i$ 与为 $0$。</p><p>直接进行数位 $\tt Dp$。</p><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>$$<br>|\bigcup_{i &#x3D; 1} ^ n S_i| &#x3D; \sum_{\empty \ne T \subseteq [n]} (-1) ^ {|T| - 1} |\bigcap_{i \in T} S_i|<br>$$</p><p>其中 $[n]$  指 ${1,2,\cdots,n}$，这个式子的含义是，这些集合并集的大小可以通过枚举一个子集的集合，将它们求交并乘上 $−1$ 的子集大小次方求和得到。</p><p>一种理解是二项式定理：</p><p>$$<br>\sum_{i &#x3D; 1} ^ n (-1) ^ i \binom{n}{i} &#x3D; \sum_{i &#x3D; 0} ^n \left((-1)^n \binom{n}{i}\right) - \binom{n}{0} &#x3D; - 1<br>$$</p><p>所以 $s$ 的每个元素恰好被计算 $1$ 次。</p><blockquote><p>考虑任意元素，其在大小为 $i$ 的集合的计算次数。</p></blockquote><p>其还有一个常见形式：</p><p>$$<br>|\bigcup_{i &#x3D; 1} ^ n S_i| &#x3D; \sum_{T \subseteq [n]} (-1) ^ {|T|} |\bigcap_{i \in T} S_i|<br>$$</p><p>聪明的你会发现这个东西就是原来的补集，我们定义 $T &#x3D; \emptyset$ 的时候后面的式子定义为全集大小。</p><p>我们可以直观地理解容斥原理：</p><ul><li>$n$ 件事至少发生一件的方案数，可以通过其中每个子集同时发生的方案计算；</li><li>$n$ 件事都不发生的方案数，可以通过其中每个子集同时发生的方案计算。</li></ul><blockquote><p>全错排问题</p><p>求 $1, \ldots, n$ 的偶爱列 $p_1, \ldots, p_n$ 的数量，使得 $i \ne p_i$。</p></blockquote><p>设 $S_i$ 为所有满足 $i &#x3D; p_i$ 的集合，我们求的就是 $\bigcup_{i &#x3D; 1} ^ n S_i$。</p><p>使用容斥原理考虑钦定了 $i$ 个 $p_i &#x3D; i$ 的方案数，可以写出答案：</p><p>$$<br>|\bigcup_{i &#x3D; 1} ^n S_i| &#x3D; \sum_{i &#x3D; 0} ^ n (-1) ^ i \binom{n}{i} (n - i) !<br>$$</p><p>我们甚至可以使用生成函数得到递推式，这个不提 $a_n &#x3D; (n - 1) (a_{n - 1} + a_{n - 2})$。</p><blockquote><p>求正整数列 $a_{1 \ldots n}$ 的数量，满足：</p><ul><li>$a_i \le x_i$</li><li>$\sum a_i &#x3D; S$</li></ul></blockquote><p>设 $S_i$ 是满足 $a_i &gt; x_i$ 的集合，我们要求 $\bigcup_{i &#x3D; 1} ^ n S_i$。</p><p>容斥原理，不妨考虑钦定 $a_i &#x3D; x_i + c$。</p><p>我们直接使用隔板法即可。</p><blockquote><p>给定 $n$ 个字符串 $T_1, \ldots, T_n$，字符串中有些问号表示可以填上任意小写字母，问所有填写方案中这些串构成的字典树结点数之和。</p></blockquote><p>考虑 $S_i$ 是字典树上第 $i$ 个串的所有前缀对应结点构成的集合，我们求 $\bigcup_{i &#x3D; 1} ^ nS_i$。</p><p>容斥原理，交集就是 $\tt Lcp$，可以通过枚举 $\tt lcp$ 长度算方案数。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/AT2062">[AGC 005 D] ~K Perm Counting</a></p><p>求 $1, \ldots, n$ 的排列 $p_1, \ldots, p_n$ 的数量，使得 $|i - p_i| \ne k$。</p></blockquote><p>容斥，不讲。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/AT4352">[ARC 101 C] Ribbons on Tree</a></p><p>将给定的包含偶数 $n$ 个点的树上的点两两配对，使得每对点之间路径的并集包含了每一条树边，求方案数。</p></blockquote><p>容斥枚举不合法的边集，考虑删除了 $E$ 之后树变成 $E + 1$ 个连通块，每个连通块都内部匹配，不妨考虑连通块大小为 $n$ 那么方案数就是 $(n - 1) !!$。</p><p>设 $f(i, j)$ 表示点 $i$ 子树中 $i$ 所在连通块大小为 $j$ 时的容斥系数。</p><p>$f(i, 0)$ 表示 $i$ 到父亲边没有被覆盖，特别计算。</p><h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><p>问题：有 $n$ 个集合 $S_1,\ldots,S_n$，我们要求其中属于恰好某指定 $k$ 个集合的元素数量，并且任选 $k$ 个集合算出来的<strong>答案是一样的</strong>。</p><p>设答案为 $g_k$，考虑求出 $f_k$ 表示钦定某属于 $k$ 个集合的元素数量，有：</p><p>$$<br>f_k &#x3D; \sum_{i &#x3D; k} ^ n g_i \binom{i}{k}<br>$$</p><p>使用容斥推出 $g_k$：</p><p>$$<br>g_k &#x3D; \sum_{S \in T} f_{|T|} \times (-1)^{|T| - k} &#x3D; \sum_{|T| &#x3D; k} ^ n f_{|T|} \times \binom{|T|}{k} \times (-1) ^ {|T| - k}<br>$$</p><p>二项式反演还有另一形式：</p><p>$$<br>\begin{aligned}<br>f_k &amp;&#x3D; \sum_{i &#x3D; 0} ^k g_i \times \binom{k}{i} \\<br>g_k &amp;&#x3D; \sum_{i &#x3D; 0} ^ k f_i \binom{k}{i} \times (-1) ^ {k - i}<br>\end{aligned}<br>$$</p><p>这里 $f_k$ 表示至多属于某指定 $k$ 个集合的元素数量。</p><p>我们还有：</p><p>$$<br>\begin{aligned}<br>f_k &#x3D; \sum_{i &#x3D; 0} ^ k g_i \times \binom{k}{i} \times (-1) ^ i \\<br>g_k &#x3D; \sum_{i &#x3D; 0} ^ k f_i \times \binom{k}{i} \times (-1) ^ i<br>\end{aligned}<br>$$</p><blockquote><p><a href="https://www.luogu.com.cn/problem/CF1228E">[CF 1228 E] Another Filling the Grid</a></p></blockquote><p>这种情况是二维的，具体讲一下二维怎么反演。</p><p>我们设 $f(a, b)$ 表示每一维钦定了 $a, b$ 是不符合条件的，$g(a, b)$ 是恰好。</p><p>我们有 ：</p><p>$$<br>f(a, b) &#x3D; \sum_{i &#x3D; a} ^ n \sum_{j &#x3D;b} ^ n g(i, j) \times \binom{i}{a} \times \binom{j}{b}<br>$$</p><p>这个是显然的。</p><p>反演的时候我们考虑一维一维进行反演，设 $h(a, b)$ 表示 $a$ 是钦定，$b$ 是恰好，我们有。</p><p>$$<br>h(a, b) &#x3D; \sum_{i &#x3D; b} ^ n (-1) ^{i - b} \binom{i}{b} f(a, i)<br>$$</p><p>$$<br>g(a, b) &#x3D; \sum_{i &#x3D; a} ^ n (-1) ^ {i - 1} \binom{i}{a} h(i, b)<br>$$</p><p>所以综合一下有：</p><p>$$<br>g(a, b) &#x3D; \sum_{i &#x3D; a} ^n \sum_{j &#x3D; b} ^ n (-1) ^ {i - a} (-1) ^{j - b} \binom{i}{a} \binom{j}{b} f(a, b)<br>$$</p><p>更高维度也是同理的，因为 $\sum$ 是可以分步反演的。</p><h3 id="莫比如斯反演"><a href="#莫比如斯反演" class="headerlink" title="莫比如斯反演"></a>莫比如斯反演</h3><blockquote><p>只讲基础内容</p></blockquote><p>自然的前缀和与差分之间就是反演，二项式反演可以看作一种“二项前缀和”和“二项差分”的转化，而莫比乌斯反演是 $Dirichlet$ 前缀和与 $Dirichlet$ 差分的转化。</p><p>设有数论函数 $g_i, f_i$ 如果满足：</p><p>$$<br>f_k &#x3D; \sum_{d | k} g_d<br>$$</p><p>那么成 $f$ 是 $g$ 的 $\tt Dirichlet $ 前缀和，$g$ 是 $f$ 的 $\tt Dirichlet $ 差分。</p><p>我们可以找到很多数论中这种运算与多项式乘法之间的关系，例如 Dirichlet 前缀和实际上就是将一个函数 $g$ 与 $1$ 函数 $1(n) &#x3D; 1$ 进行 Dirichlet 卷积（其实就是高维多项式卷积）的结果，一如前缀和可以看成一个函数与 $\frac{1}{x - 1}$ 的卷积，事实上 <strong>Dirichlet 前缀和就是高维前缀和</strong>。</p><p>设 $k$ 有 $c$ 个素因子 $p_1, \ldots, p_c$，$c$ 维函数 $F(a_1, \ldots, a_c)$ 的前缀和，其差分为：</p><p>$$<br>G(a_1, \ldots, a_c) &#x3D; \sum_{S \in [c]} F(a_1 - [1 \in S], \ldots, a_c - [c \in S]) (-1) ^ {|S|}<br>$$</p><p>在数论背景下，这个就是 $\mu(k)$。</p><p>所以我们有 $g_k &#x3D; \sum_{d | k} f_d \times \mu(\frac{k}{d})$。</p><p>这就是<strong>莫比乌斯反演</strong>，这和上面的高维差分是等价的，这告诉我们数论函数的 Dirichlet 差分由它与莫比乌斯函数卷积得到。</p><p>对于后缀和也有类似的反演形式：</p><p>$$<br>f_k &#x3D; \sum_{d | k} g_d<br>$$</p><p>$$<br>g_k &#x3D; \sum_{d | k} f_d \times \mu(\frac{d}{k})<br>$$</p><p>还有 $\varphi &#x3D; \mu \times id, id &#x3D; \varphi \times 1, \mu \times 1 &#x3D; \epsilon$，其中 $\epsilon(n) &#x3D; [n &#x3D; 1]$。</p><p>我们通常将 $\gcd(a, b) &#x3D; d$ 转化成 $d | \gcd(a, b)$。</p><h3 id="Min-Max-容斥"><a href="#Min-Max-容斥" class="headerlink" title="Min - Max 容斥"></a>Min - Max 容斥</h3><p>Min-Max 容斥是一种将集合最大值用其子集最小值表示的方法，当然由于相对全体实数来说，Min 和 Max 这两种运算是对称的，所以反过来也成立。</p><p>设有数集 $S$ 令 $\max(S), \min(S)$ 分别表示其中最大值和最小值那么有：</p><p>$$<br>\max(S) &#x3D; \sum_{\emptyset \ne T \subseteq S} (-1) ^{|T| - 1} \min(T)<br>$$</p><p>设 $S &#x3D; {S_1, \ldots, S_n}$，令 $T_i$ 表示不大于 $S_i$ 的正整数集合，则 $\max(S) &#x3D; |\bigcup T_i|, \min(S) &#x3D; |\bigcap T_i|$。就是基础的容斥原理。</p><p>由于 $\max(S) &#x3D; - \min(-S)$。</p><p>我们也有：</p><p>$$<br>\min(S) &#x3D; \sum_{\emptyset \ne T \subseteq S} (-1) ^{|T| - 1} \max(T)<br>$$</p><p>到这里，观察普通的容斥和 Min-Max 容斥，我们已经注意到了：</p><ul><li>针对集合的普通容斥中，<strong>包含</strong>是定义在集合上的偏序关系，而交并分别是取下界和上界；</li><li>针对实数的 Min-Max 容斥中，<strong>不大于</strong>是定义在实数集合上的偏序关系，而 ⁡$\min,\max$ 分别是取下界和上界。</li></ul><p>由整数的整除偏序可以导出 <strong>GCD-LCM 容斥</strong>：</p><p>$$<br>\gcd(S) &#x3D; \prod_{\emptyset \ne T \subseteq S} (lcm(T)) ^ {(-1) ^{ |T| - 1}}<br>$$</p><p>$$<br>lcm(S) &#x3D; \prod_{\emptyset \ne T \subseteq S} (\gcd(T)) ^ {(-1) ^{ |T| - 1}}<br>$$</p><p>考虑如何使用子集的 $\tt min$ 表示出一个集合的第 $k$ 大数:</p><p>$$<br>\max_k(S) &#x3D; \sum_{T \subseteq S, |T| \ge k} (-1) ^ {|T| - k} \times \binom{|T| - 1}{k - 1} \times \min(T)<br>$$</p><p>证明同样考虑贡献，由于 $|T| \ge k$，所以比第 $k$ 大数更大的数一定不会再右边出现。</p><p>然后考虑第 $l &gt; k$ 大的数的贡献，它是：</p><p>$$<br>\sum_{i &#x3D; k} ^ l (-1) ^ {i - k} \times \binom{i - 1}{k - 1} \times \binom{l - 1}{i - 1} &#x3D; \binom{l - 1}{k - 1} \sum_{i &#x3D; k} ^ l (-1) ^ {i - k} \binom[l - k]{i - k}<br>$$<br>后者只有 $l &#x3D; k$ 时才为 $1$。</p><p>Min-Max 容斥的一个常见用途也是将“完全”转化为“至少”，假设有 $n$ 个事件，我们需要计算它们全部发生的期望时间，可以转化为计算某个子集至少发生一件的期望时间。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4707">P4707 重返现世</a></p><p>有 $n$ 种原料，美妙随机生成一种，生成第 $i$ 中的概率为 $\dfrac{p_i}{m} (m &#x3D; \sum p_i)$，问第一次集齐 $k$ 中原料的期望时间。</p></blockquote><p>考虑选取集合需要进行 $\tt Dp$ 设 $f(i, j, k)$ 表示考虑了前 $i$ 个数选择了 $j$ 个 $\sum p &#x3D; k$ 的方案数。<br>$$<br>f(i, j, k) &#x3D; f(i - 1, j, k) + f(i - 1, j - 1,p - p_i)<br>$$<br>复杂度是 $O(n^2m)$ 的。</p><p>下面就需要优化了，一般这种 DP 的优化思路就是<strong>将一部分系数通过组合意义或组合恒等式化到 DP 值中去</strong>，这里我们就进行这样的尝试。</p><p>首先这个 $k$ 不妨变成收集了 $k$ 个材料中任意一个的最小时间。</p><p>那么不妨假设集合为 $P$ 没有收集到该集合的概率为 $u &#x3D; \frac{\sum_{x \not \in P} p_x}{m}$。</p><p>所以我们期望时间为 $\frac{1}{1 - u}$。</p><p>考虑 $n -k &#x3D; 10$ 的限制，我们不妨考虑求第 $k$ 大。</p><p>那么 $q &#x3D; n - k + 1$。</p><p>之后考虑对于相同的 $\sum p$ 我们的 $\min(T)$ 本质是一样的，所以我们只需要求前面部分的系数和。</p><p>如果不选转移比较显然，考虑选择的情况：<br>$$<br>\sum_{T \subseteq S, |T| \ge q} (-1) ^ {|T| - q} \times \binom{|T| - 1}{q - 1}<br>$$<br>考虑拆开得到 $\binom{|T| - 1}{q - 1} &#x3D; \binom{|T| - 2}{q - 2} + \binom{|T| - 2}{q - 1}$，发现我们只需要知道 $q$ 就可以在转移了。</p><p>考虑更改状态设 $f(i, j, p)$ 表示考虑前 $i$ 个，$q &#x3D; j, \sum p_i &#x3D; p$ 的系数和。</p><p>发现左边部分就是 $f(i - 1, j - 1, p - p_i)$ 对于右边部分是 $f(i - 1, j, p - p_i)$，考虑配一下系数。</p><p>前者是 $-$ 后者是 $+$。</p><p>所以 $f(i, j, p) &#x3D; f(i - 1, k, p) + f(i - 1, j, p - p_i) - f(i - 1, j - 1, p - p_i)$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3175">P3175 [HAOI2015]按位或</a></p><p>有一个初始为 $0$ 的数 $x$，美妙按照数 $i$ 权重 $p_i$ 来随机选择一个 $[0, 2^n - 1]$ 中的数，然后将 $x$ 或上这个数，求第一次 $x$ 变为 $2^n - 1$ 的期望时间。</p></blockquote><p>考虑 $x$ 二进制第 $i$ 个 $1$ 出现时间为 $t_i$ 我们要求 $\max(t_i)$ 的期望， 就是需要求子集 $T$，$\min(T)$ 的期望。</p><p>同理可得期望时间为：<br>$$<br>\frac{1}{1 - \sum_{x \not \in T} p_x}<br>$$<br>需要计算子集和使用 $\tt FWT$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5644">P5644 [PKUWC2018]猎人杀</a></p><p>按如下规则构造 $1, \ldots, n$ 的排列，每次从未被选择的元素中以第 $i$ 个元素 $p_i$ 的权重随机选择一个，求 $1$ 是最后一个的概率。 </p></blockquote><p>发现直接计算不方便，考虑容斥设 $1$ 之后钦定去世的点集合为 $S$。</p><p>不妨考虑这个概率为 $p(S)$ 那么我们的答案就是 $\sum_S p(S) (-1) ^{|S|}$。</p><p>设 $sum(S) &#x3D; \sum_{i \in S} a_i$ 考虑如何求 $p(S)$。</p><p>因为至少包含点集 $S$ 内的所有人考虑之前 $\tt uoj$ 喂鸽子的套路，考虑无限开枪，我们有：<br>$$<br>p(S) &#x3D; \sum_{i\ ge 0} \left(\frac{tot - a_1  - sum(S)}{tot}\right)^ i \frac{a_1}{tot} &#x3D; \frac{a_1}{a_1 + sum(S)}<br>$$<br>那么有：<br>$$<br>ans &#x3D; \sum (-1) ^ {|S|} \frac{a_1}{a_1 + sum(S)}<br>$$<br>题目中给出 $\sum w_i &#x3D; 10^5$ 会想到生成函数。</p><p>考虑对于同一个 $sum(S)$ 计算其系数设为 $f(sum(S))$。<br>$$<br>ans &#x3D; \sum_{i &#x3D; 0} ^ {tot} f(i) \frac{a_1}{a_1 + i}<br>$$<br>考虑每个向是否可以选择显然是 $\prod_{i &#x3D; 2} ^ n (1 - x^{w_i})$。</p><p>使用分治 $\tt NTT$ 求出。</p><h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>很入门的东西已经写过很多了，就不谈了。</p><ul><li><h4 id="color-blue-Delta-牛顿迭代"><a href="#color-blue-Delta-牛顿迭代" class="headerlink" title="$\color{blue}\Delta$ 牛顿迭代"></a>$\color{blue}\Delta$ 牛顿迭代</h4></li></ul><p>根据群论我们知道 $\ge 5$ 次的方程是没有根式解的，我们考虑如何逼近求出这个解。不妨设 $r$ 是 $f(x) &#x3D; 0$ 的一个解。</p><p>选取 $x_0$ 作为初始近似值，我们可以过点 $(x_0, f(x_0))$ 做曲线 $y &#x3D; f(x)$ 的切线 $L$ 我们知道切点与 $x$ 轴有交点。</p><p>$L:y &#x3D; f(x_0) + (x - x_0)f’(x_0)$ 其与 $x$ 的交点为 $x_1 &#x3D; x_0 - \frac{f(x_0)}{f’(x_0)}$。</p><p>那么我们就有了迭代公式。</p><p>逝一逝：</p><blockquote><p>多项式 $\exp$。</p><p>给定 $F(x)$，求满足 $\exp(F(x)) \equiv G(x) \pmod {x^n}$ 的 $G(x)$。</p></blockquote><p>$$<br>\begin{aligned}<br>\exp(F(x)) &amp;\equiv G(x) \\<br>F(x) &amp;\equiv \ln G(x) \\<br>\ln G(x) - F(x) &amp;\equiv 0<br>\end{aligned}<br>$$</p><p>考虑通过牛顿迭代求出 $G(x)$ 不妨设 $H(x) &#x3D; \ln x - F(x)$。</p><p>带入上述公式得到：<br>$$<br>G_1(x) &#x3D; G_0(x) - \frac{\ln G_0(x) - F(x)}{\frac{G_0’(x)}{G_0(x)}} &#x3D; \frac{G_0(x) (1 - \ln G_0(x) + F(x))}{G_0’(x)}<br>$$<br>因为 $a_0 &#x3D; 0$，发现对于 $n &#x3D; 1$ 的情况我们是可以直接得到答案 $g_0 &#x3D; 1$，之后通过迭代来增加幂次即可。</p><ul><li><h4 id="color-blue-Delta-欧拉变换"><a href="#color-blue-Delta-欧拉变换" class="headerlink" title="$\color{blue}\Delta$ 欧拉变换"></a>$\color{blue}\Delta$ 欧拉变换</h4></li></ul><p>设一个 $ogf$ 是 $A(x)$ 的<strong>无标号</strong>组合类 $S$，其中大小为 $i$ 的对象有 $a_i$ 个。</p><ul><li>每个对象是 $S$ 中若干个对象的组成的多重集。</li></ul><p>我们称这个操作为欧拉变换，记作 $\mathcal E(A(x))$，这个东西就是一个完全背包考虑直接进行 $\tt Dp$ 本质上就是给答案乘上 $(1 + x^i +x^{2i}\cdots)$。<br>$$<br>\mathcal E(A(x)) &#x3D; \prod_{i &#x3D; 1} \frac{1}{(1 - x^i)^{a_i}}<br>$$</p><ul><li>每个对象是 $S$ 若干个对象的不可重集。</li></ul><p>$$<br>C(x) &#x3D; \prod_{i &#x3D; 1} (1 +x^i) ^{a_i}<br>$$</p><p>如何计算 $\mathcal E(A(x))$，乘积式的常见处理手法是化乘为加。<br>$$<br>\begin{aligned}<br>\mathcal E(A(x)) &amp;&#x3D; \exp(\ln \prod_{i&#x3D; 1} (1 - x^i) ^ {-a_i}) \\<br>&amp;&#x3D; \exp(- \sum_{i &#x3D; 1} a_i \sum_{i | j} - \frac{i}{j}x^j) \\<br>&amp;&#x3D; \exp(\sum_{i &#x3D; 1} a_i \sum_{j &#x3D; 1}\frac{x^{ij}}{j})<br>\end{aligned}<br>$$<br>复合的计算需要使用拉反之类的。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4389">P4389 付公主的背包</a></p><p>有 $n$ 个物品，第 $i$ 个大小为 $v_i$，有无限建，对每个 $i \in [1, m]$，求选择一些物品大小和为 $i$ 的方案数，不区分放入物品的顺序。</p></blockquote><p>物品无标号，组合无标号，就是 $\mathcal E(x)$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5748">P5748 集合划分计数</a></p><p>求出 $\tt bell(n)$ 表示将集合 ${1, 2, \ldots, n}$ 划分为若干个无标号非空子集的方案数。</p></blockquote><p>集合是 ${1, 2, \ldots, n}$ 本身是有标号的，划分成无标号子集，组合是无标号的。</p><p>使用 $\tt egf$ 做 $\exp$，我们只需要做出每个非空子集的生成函数就是 $e^x - 1$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/CF438E">CF438E The Child and Binary Tree</a></p><p>求有多少点带权二叉树，点权在给定集合 $S$ 中（$|S| &#x3D; n$），且所有点的点权和为 $m$，二叉树点无标号，但区分左右儿子。</p></blockquote><p>二叉树大小为点权和，设 $\tt ogf$ 是 $F(x)$，集合的生成函数是 $G(x)$。</p><p>$F(x) &#x3D; G(x)F^2(x) + 1$。这里 $+1$ 表示递归 $f_0$ 的时候，也就是点权为 $0$ 的树的方案数。<br>$$<br>F(x) &#x3D; \frac{1 \pm \sqrt{1 - 4G(x)}}{2G(x)}<br>$$<br>对于 $f_0 &#x3D; 1$ 我们带入 $x &#x3D; 0$ 观察是否复合答案。</p><p>使用分母无理化：<br>$$<br>F(x) &#x3D; \frac{2G(x)}{1 \pm \sqrt{1 - 4G(x)}}<br>$$<br>显然下面取 $+$ 所以上面取 $-$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5824">十二重计数法 X</a></p><p>将 $n$ 划分成 $m$ 个无序自然数之和的方案数。 </p></blockquote><p>考虑最终划分之后的数，因为 $n &#x3D; \sum_{i \ge 1} [n \ge i]$，设 $t_x$ 表示划分之后 $\ge x$ 的数个数。</p><blockquote><p>因为每个数 $a$ 会对 $1 \sim a$ 做贡献，根据 $n$ 的那个式子拆分。</p></blockquote><p>因为 $t_x \in [1, m]$ 本质上就是背包。<br>$$<br>[x^n] \prod_{i &#x3D; 1} ^ m \frac{1}{1 - x^i}<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;加乘原理&quot;&gt;&lt;a href=&quot;#加乘原理&quot; class=&quot;headerlink&quot; title=&quot;加乘原理&quot;&gt;&lt;/a&gt;加乘原理&lt;/h3&gt;&lt;p&gt;对于给定的集合 $S$ 对于其中满足某一性质 $P$ 的元素 $x$ 求和 $f(x)$ 即求出：&lt;/p&gt;
&lt;p&gt;$$&lt;br</summary>
      
    
    
    
    <category term="算法" scheme="https://legendgod.ml/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数论" scheme="https://legendgod.ml/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="反演" scheme="https://legendgod.ml/tags/%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>P4351 [CERC2015]Frightful Formula 题解</title>
    <link href="https://legendgod.ml/2022/04/22/lg-solution-4351/"/>
    <id>https://legendgod.ml/2022/04/22/lg-solution-4351/</id>
    <published>2022-04-22T06:43:00.000Z</published>
    <updated>2022-11-11T11:18:54.377Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4351">P4351 [CERC2015]Frightful Formula</a></p><p>首先将原来的式子看成网格的贡献，发现 $c$ 比较难处理，我们先不管 $c$。</p><p>那么 $a, b$ 本质就是向右走一步和向下走一步的贡献。</p><p>那么对于位置 $(x, y)$ 其最终的贡献是 $\dbinom{2n - x - y}{n - x} \times a^{n - x} b^{n - y}$。</p><p>我们只需要考虑 $(1, i), (i, 1)$ 即可。</p><p>之后考虑 $c$ 的贡献怎么计算，发现位置 $\forall i, j, i \ge 2, j \ge 2$ 会产生贡献。</p><p>显然 $c$ 的贡献同上。<br>$$<br>ans &#x3D; \sum_{i &#x3D; 1} ^ n \binom{2n - 1 - i}{i} (a^{n - 1} b^{n - i} + a^{n - i}b^{n - 1} )  + c\sum_{i &#x3D; 2} ^ n \sum_{j &#x3D; 2} ^ n \binom{2n - i - j}{n - j} a^{n - i}b^{n - j}<br>$$<br>前面部分可以直接计算，考虑计算后面的部分。</p><p>后面等价于 $c\sum_{i &#x3D; 0} ^ {n - 2} \sum_{j &#x3D; 0} ^ {n - 2} a^i b^j \binom{i + j}{i}$，发现就是一个卷积的形式。</p><p>设 $u &#x3D; n - 2, A(x) &#x3D; \sum_{i &#x3D; 0} ^ u a^i \frac{x^i}{i!}, B(x) &#x3D; \sum_{i &#x3D; 0} ^ u b^i\frac{x^i}{i!}$，答案就是 $\sum_{i &#x3D; 0} ^ {2u} [x^i] i!A(x)B(x)$。</p><p>考虑进行这里提到的<a href="https://legendgod.ml/2022/02/28/generating-function/">经典变换</a>。</p><p>设 $F(x) &#x3D; A(x)B(x)$，我们有：<br>$$<br>\begin{aligned}<br>F’ &amp;&#x3D; AB’ + A’B \\<br>&amp;&#x3D; A \times (bB - b^{u + 1} \frac{x^u}{u!}) + B \times (aA - a^{u + 1}\frac{x^u}{u!}) \\<br>&amp;&#x3D; (a +b)F - \frac{x^u}{u!} (Ab^{u + 1} + Ba^{u + 1})<br>\end{aligned}<br>$$<br>可以直接对于上式提取系数：<br>$$<br>f(i + 1) &#x3D; (a + b) f(i) - \binom{i}{u}(b^{u + 1}a^{i - u} + a^{u +1}b^{i - u})<br>$$<br>事实上我们只要递推 $i &#x3D; n - 1 \sim 2n - 4$ 的部分。</p><p>对于前面的部分可以发现：<br>$$<br>\sum_{i + j &#x3D; 0} ^ {n - 2} \binom{i + j}{i} a^ib^j &#x3D; \sum_{i + j &#x3D; 0} ^ {n - 2} (a + b) ^{i + j}<br>$$<br>可以直接进行计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A, B, c;</span><br><span class="line"><span class="keyword">int</span> fac[maxn], finv[maxn], pwa[maxn], pwb[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(mi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    finv[x] = <span class="built_in">Inv</span>(fac[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) finv[i] = <span class="number">1ll</span> * finv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    pwa[<span class="number">0</span>] = pwb[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++ i) pwa[i] = <span class="number">1ll</span> * pwa[i - <span class="number">1</span>] * A % mod, pwb[i] = <span class="number">1ll</span> * pwb[i - <span class="number">1</span>] * B % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * fac[a] * finv[b] % mod * finv[a - b] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn], l[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, A, B, c);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(l[i]);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(t[i]);</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        tmp += <span class="number">1ll</span> * <span class="built_in">C</span>(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) * pwa[n - <span class="number">1</span>] % mod * pwb[n - i] % mod * l[i] % mod;</span><br><span class="line">        tmp += <span class="number">1ll</span> * <span class="built_in">C</span>(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) * pwb[n - <span class="number">1</span>] % mod * pwa[n - i] % mod * t[i] % mod;</span><br><span class="line">        res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">now</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n - <span class="number">2</span>; ++ i) res = (res + <span class="number">1ll</span> * c * now) % mod, now = <span class="number">1ll</span> * now * (A + B) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf(&quot;res = %d\n&quot;, res);</span></span><br><span class="line">    f[n - <span class="number">2</span>] = <span class="built_in">ksm</span>(A + B, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> u = n - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">2</span>; i &lt; <span class="number">2</span> * n - <span class="number">4</span>; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = ( <span class="number">1ll</span> * pwb[u + <span class="number">1</span>] * pwa[i - u] + <span class="number">1ll</span> * pwa[u + <span class="number">1</span>] * pwb[i - u] ) % mod;</span><br><span class="line">        f[i + <span class="number">1</span>] = <span class="number">1ll</span> * (A + B) * f[i] % mod - <span class="number">1ll</span> * <span class="built_in">C</span>(i, u) * tmp % mod;</span><br><span class="line">        f[i + <span class="number">1</span>] = (f[i + <span class="number">1</span>] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &lt;= <span class="number">2</span> * u; ++ i) res = (res + <span class="number">1ll</span> * c * f[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4351&quot;&gt;P4351 [CERC2015]Frightful Formula&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先将原来的式子看成网格的贡献，发现 $c$ 比较难处理，我们先不管 $c$。&lt;/p&gt;</summary>
      
    
    
    
    <category term="洛谷题解" scheme="https://legendgod.ml/categories/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数论" scheme="https://legendgod.ml/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>AT3956 [AGC023E] Inversions 题解</title>
    <link href="https://legendgod.ml/2022/04/22/at-solution-agc023e/"/>
    <id>https://legendgod.ml/2022/04/22/at-solution-agc023e/</id>
    <published>2022-04-22T00:54:00.000Z</published>
    <updated>2022-11-11T11:18:54.369Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/AT3956">AT3956 [AGC023E] Inversions</a></p><p>首先来看总方案数怎么算，如果将每个数按照 $a_i$ 排序其排名为 $b_i$，设 $c_i &#x3D; a_{b_i}$。<br>$$<br>f(n) &#x3D; \prod_{i &#x3D; 1} ^ n (c_i - i + 1)<br>$$<br>考虑对于每个逆序对单独计算贡献，考虑 $i &lt; j, a_i &lt; a_j$。</p><p>可以让 $a_j &#x3D; a_i$ 之后进行计算。<br>$$<br>g(i, j) &#x3D; \frac{1}{2} \times f(n) \times \frac{a_i - b_i}{a_j - b_j + 1} \times \prod_{k &#x3D; b_i + 1} ^ {b_j - 1} \frac{c_k - k}{c_k - k + 1}<br>$$<br>对于 $i &gt; j, a_i &lt; a_j$ 的情况，考虑逆序对不好计算使用补集转化。<br>$$<br>f(n) - g(i, j)<br>$$<br>那么我们只需要求出 $g(i, j)$ 即可。</p><p>考虑对于每个 $j$ 考虑其前缀的贡献，对于 $\dfrac{f(n) \times \dfrac{a_i - b_i}{a_j - b_j + 1}}{2}$ 是固定的。</p><p>之后按照排名从小到大加入位置 $p$ 如果其作为 $i$ 那么需要给位置乘上 $a_p - b_p$ 如果是作为 $j$ 那么首先计算贡献，之后全局乘上 $\prod $ 部分的贡献。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> t[maxn &lt;&lt; <span class="number">2</span>], tg[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs (p &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        tg[p] = <span class="number">1</span>, t[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">build</span>(ls, l, mid), <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        t[p] = (t[ls] + t[rs]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        t[p] = <span class="number">1ll</span> * t[p] * c % mod, tg[p] = <span class="number">1ll</span> * tg[p] * c % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tg[p] == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">Add</span>(ls, tg[p]), <span class="built_in">Add</span>(rs, tg[p]);</span><br><span class="line">        tg[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> t[p] = c, <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(pos &lt;= mid) <span class="built_in">Insert</span>(ls, l, mid, pos, c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">Insert</span>(rs, mid + <span class="number">1</span>, r, pos, c);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> ll,<span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ll &gt; rr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> t[p];</span><br><span class="line">        <span class="built_in">pushdown</span>(p);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= mid) res += <span class="built_in">Ask</span>(ls, l, mid, ll, rr) % mod;</span><br><span class="line">        <span class="keyword">if</span>(mid &lt; rr) res += <span class="built_in">Ask</span>(rs, mid + <span class="number">1</span>, r, ll, rr) % mod;</span><br><span class="line">        <span class="keyword">return</span> res % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br><span class="line">&#125;T1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">for</span>(; p &lt;= n; p += <span class="built_in">lowbit</span>(p)) t[p] += c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="keyword">for</span>(; p &gt; <span class="number">0</span>; p -= <span class="built_in">lowbit</span>(p)) res += t[p]; <span class="keyword">return</span> res; &#125;</span><br><span class="line">&#125;T2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, id;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; z) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v == z.v ? id &lt; z.id : v &lt; z.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(mi) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mi &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * x % mod;</span><br><span class="line">        mi &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = <span class="number">1ll</span> * x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(a[i].v), a[i].id = i;</span><br><span class="line">    T1.<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) fn = <span class="number">1ll</span> * fn * (a[i].v - i + <span class="number">1</span>) % mod;</span><br><span class="line"><span class="comment">//    printf(&quot;fn = %d\n&quot;, fn);</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        tmp = T1.<span class="built_in">Ask</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, a[i].id - <span class="number">1</span>) + mod - T1.<span class="built_in">Ask</span>(<span class="number">1</span>, <span class="number">1</span>, n, a[i].id + <span class="number">1</span>, n);</span><br><span class="line">        tmp %= mod;</span><br><span class="line">        tmp = (<span class="number">1ll</span> * tmp * <span class="built_in">Inv</span>(<span class="number">2</span> * (a[i].v - i + <span class="number">1</span>) % mod) % mod * fn % mod + <span class="number">1ll</span> * fn * ( T2.<span class="built_in">ask</span>(n) - T2.<span class="built_in">ask</span>(a[i].id) ) % mod) % mod;</span><br><span class="line">        res = (res + tmp) % mod;</span><br><span class="line">        T1.<span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1ll</span> * (a[i].v - i) * <span class="built_in">Inv</span>(a[i].v - i + <span class="number">1</span>) % mod);</span><br><span class="line">        T1.<span class="built_in">Insert</span>(<span class="number">1</span>, <span class="number">1</span>, n, a[i].id, (a[i].v - i));</span><br><span class="line">        T2.<span class="built_in">add</span>(a[i].id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/AT3956&quot;&gt;AT3956 [AGC023E] Inversions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先来看总方案数怎么算，如果将每个数按照 $a_i$ 排序其排名为 $b_i$，设 $c_i &amp;</summary>
      
    
    
    
    <category term="AT题解" scheme="https://legendgod.ml/categories/AT%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数论" scheme="https://legendgod.ml/tags/%E6%95%B0%E8%AE%BA/"/>
    
    <category term="线段树" scheme="https://legendgod.ml/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>图论回忆1</title>
    <link href="https://legendgod.ml/2022/04/15/remind-graph1/"/>
    <id>https://legendgod.ml/2022/04/15/remind-graph1/</id>
    <published>2022-04-15T01:08:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>据说图论我会的东西相对少一点，我们先写图论。</p></blockquote><h2 id="二分图概念和判定"><a href="#二分图概念和判定" class="headerlink" title="二分图概念和判定"></a>二分图概念和判定</h2><p><strong>定义</strong>：对于无向图 $G &#x3D; (V, E)$ 存在将 $V$ 划分成两个不相交子集 $A, B$ 满足集合内部没有连边，则 $G$ 为二分图。</p><p><strong>定理</strong>：图 $G &#x3D; (V, E)$ 是二分图，当且仅当 $G$ 中没有奇环。</p><p><strong>推论</strong>：二分图 $G &#x3D; (V, E)$ 的任意子图为二分图。</p><p><strong>推论</strong>：二分图 $G &#x3D; (V, E)$ 是二分图，当且仅当其任意连通子图是二分图。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P1330">封锁阳光大学 - 洛谷</a></p><p>给定一张图，求是否存在点集 $V$ 满足任意一条边只有一个顶点在 $V$ 中。</p></blockquote><p>本质上就是分成两个集合，使得集合内部没有边，就是二分图。</p><p>直接染色之后取点数小的即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P1525">[NOIP2010 提高组] 关押罪犯 - 洛谷</a></p><p>给定一张无向带权图，将图分成两个集合，使得集合内部边权的最大值最小。</p></blockquote><p>考虑权值大的肯定尽量是两个集合之间的边，考虑二分答案，之后找到不合法的边钦定一定要分为两个集合，设二分的答案为 $X$ 或者说建立图 $G &#x3D; (V, E), E &#x3D; { w &gt; X | (u, v, w) }$，是一个二分图。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5292">[HNOI2019]校园旅行 - 洛谷</a></p><p>给定以一张无向图，每个点有点权 $0, 1$，对于 $q$ 个询问 $s, t$ 求是否存在 $s \to t$ 的一条路径使得路径上的点权是回文串。</p><p>$O(V^2 + q)$。</p></blockquote><p>能否直接预处理出来两个点之间的答案，考虑一个点到另外一个点点数的奇偶性是固定的。</p><p>对于标记全部是相同的大小 $\ge 2$ 的连通分量，只需要考虑其增加这一段的奇偶性，如果该连通分量是二分图那么改变的奇偶性是固定的。</p><ul><li>二分图只要保留一个生成树就行了。</li></ul><blockquote><p>因为树也是二分图。</p></blockquote><ul><li>如果不是二分图，直接考虑生成树之后在根节点加一个自环就行了。</li></ul><p>对于连接不同颜色的边我们肯定是一个二分图，所以保留生成树就行了，所以边数是 $O(n)$ 的。</p><p>考虑暴力枚举转移的边，之后进行 $\tt bfs&#x2F;SPFA$ 转移即可。</p><h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><p>对于给定 $G &#x3D; (V, E)$，求出最大的边集 $A \subseteq E$ 使得没有两条有共同端点的边。</p><p><strong>增广路定义：</strong> 对于一个没匹配端点节点 $p$ 出发，交题经过在 $A$ 中和不在 $A$ 中的边，到达一个没匹配节点。那么这条路径被称为一条增广路。</p><p><strong>匈牙利算法：</strong></p><p>如果 $P$ 是二分图最大匹配，当且仅当图中不存在增广路。首先必要性显然，考虑充分性。</p><ol><li>不会出现可以直接加入匹配的边。</li><li>如果修改边的匹配那么一定存在一条路径上面的边进行翻转，但是已经没有增广路了，所以不存在。</li></ol><p>综上充分性成立。</p><p><strong>实现过程：</strong></p><p>维护 $1 \sim i - 1$ 点的最大匹配，每次寻找增广路。</p><p>如果设左边点的标号为 $1$，右边为 $0$ 那么最大匹配就是最大字典序的。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P1963">[NOI2009] 变换序列 - 洛谷</a></p><p>给定数列 $A_{1 \sim n}$ 求字典序最小的排列 $P$ 使得 $|P_i - i| &#x3D; A_i$。</p></blockquote><p>考虑对于每个 $i$ 其确定了连接的两条或者一条边，直接进行连边。</p><p>那么左边是 $P_i$ 右边是 $i$，找到最大匹配就是答案。</p><p>考虑从后向前跑就是字典序最小的了。</p><h3 id="二分图最小点覆盖"><a href="#二分图最小点覆盖" class="headerlink" title="二分图最小点覆盖"></a>二分图最小点覆盖</h3><p><strong>定理</strong>：二分图最小点覆盖大小等于最大匹配大小。</p><p><strong>推论</strong>：任何一组点覆盖大小 $\ge$ 任何一组匹配大小。</p><p>二分图最大匹配的线性规划形式：</p><p>$$<br>\begin{aligned}<br>&amp;\max\sum_{i &#x3D; 1} ^ m x_i \\<br>&amp;s.t.<br>\begin{cases}<br>\sum_{i &#x3D; 1} ^ n w(j, i) x_i \le 1\\<br>x_i \ge 0<br>\end{cases}<br>\end{aligned}<br>$$</p><p>其中 $x_i$ 表示该边是否选择，$w(j, i)$ 表示点 $i$ 是否被边 $j$ 选择。</p><p>其对偶问题是：</p><p>$$<br>\begin{aligned}<br>&amp;\min\sum_{j &#x3D; 1} ^ m y_j \\<br>&amp;s.t.<br>\begin{cases}<br>\sum_{j &#x3D; 1} ^ m w(j, i) y_j \ge 1\\<br>y_j \ge 0<br>\end{cases}<br>\end{aligned}<br>$$</p><p>其中 $y_j$ 表示点 $j$ 是否被选择。</p><blockquote><p>$\tt ix35:$ 我们可以证明：上面问题中的代价矩阵是一个<strong>全幺模矩阵</strong>，因此其最优解等于整数规划解，即 $x_i \in {0, 1}$，这说明了我们用线性规划描述二分图匹配的合理性。</p></blockquote><h3 id="二分图最大独立集"><a href="#二分图最大独立集" class="headerlink" title="二分图最大独立集"></a>二分图最大独立集</h3><p><strong>定理</strong>：最大独立集和最小点覆盖之和等于点数。</p><p><strong>推论</strong>：二分图最大独立集大小与最大匹配大小之和等于点数。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3355">骑士共存问题 - 洛谷</a></p><p>在 $n \times m$ 的棋盘上最多放置多少不会相互攻击的骑士。</p></blockquote><p>考虑让 $2|i + j$ 成为左部点，剩下成为右部点。对于点的限制两两连边，本质上就是求最大独立集。</p><h3 id="二分图最小边覆盖"><a href="#二分图最小边覆盖" class="headerlink" title="二分图最小边覆盖"></a>二分图最小边覆盖</h3><p><strong>定义</strong>：用最少的边覆盖所有点。</p><p>如果不存在孤立点，答案就等于最大独立集大小。</p><h3 id="有向无环图最小路径覆盖"><a href="#有向无环图最小路径覆盖" class="headerlink" title="有向无环图最小路径覆盖"></a>有向无环图最小路径覆盖</h3><p>求 $\tt DAG$ 的最小路径覆盖。</p><p>构造拆点二分图，有如下定理：</p><p><strong>定理</strong>：最小路径覆盖 $&#x3D;|V| - $ 拆点二分图最大匹配。</p><blockquote><p>根据 $\tt Dilworth$ 定理，考虑路径是一个偏序集，那么最小链覆盖等于最大反链长度。</p></blockquote><blockquote><p><strong>链定义：</strong> $\forall (x, y) \in V, x \to y \ \cup\  y \to x$。</p></blockquote><blockquote><p><strong>反链定义：</strong> $\forall(x, y) \in V, x \not\to y \ \cap \ y \not \to x$。</p></blockquote><blockquote><p>所以反链本质就是一个独立集，这样的独立集 $&#x3D;|V| - $ 最大匹配。</p></blockquote><blockquote><p>如何求 $\tt DAG$ 的最大匹配呢？直接拆点二分图。</p></blockquote><p>考虑拆点二分图 $G_0$。</p><ul><li>对于路径 $v_1 \to v_2 \to \cdots \to v_n$ 可以表示成 $v_i \to v_{i + 1}$ 因为路径不相交，所以肯定是可以表示成匹配的形式。</li><li>$G_0$ 的一组匹配同上可以构造成 $G$，对于没有边经过的点都视为被空路经过。</li></ul><blockquote><p><a href="https://www.luogu.com.cn/problem/P4298">[CTSC2008]祭祀 - 洛谷</a></p><p>貌似是我多年前以为找不到的原题。</p><p>给定的 $\tt DAG, G &#x3D; (V, E)$，求最大的 $A \subseteq V$ 使得 $\forall x, y \in A,$ 不存在 $x$ 到 $y$ 的路径。</p></blockquote><p>本质上就是最大独立集，先一手传递闭包。最大反链就是最小链覆盖。</p><h3 id="二分图最大权匹配"><a href="#二分图最大权匹配" class="headerlink" title="二分图最大权匹配"></a>二分图最大权匹配</h3><p><strong>定义</strong>：给定二分图 $G &#x3D; (V, E)$，每条边有权值 $w_i$ 我们需要找到一组匹配使得边权最大。</p><blockquote><p>不一定是最大匹配。</p></blockquote><p>还是使用线性规划，$x_i$ 表示 边 $i$ 是否选择。</p><p>$$<br>\begin{aligned}<br>&amp;\max\sum_{i &#x3D; 1} ^ m w_i x_i \\<br>&amp;s.t.<br>\begin{cases}<br>\sum_{i &#x3D; 1} ^ n w(j, i) x_i \le 1\\<br>x_i \ge 0<br>\end{cases}<br>\end{aligned}<br>$$</p><p>依旧对偶：</p><p>$$<br>\begin{aligned}<br>&amp;\min\sum_{j &#x3D; 1} ^ m y_j \\<br>&amp;s.t.<br>\begin{cases}<br>\sum_{j &#x3D; 1} ^ m w(j, i) y_j \ge w_i\\<br>y_j \ge 0<br>\end{cases}<br>\end{aligned}<br>$$</p><p>我们设 $y_i$ 表示点 $i$ 的顶标，那么本质上就是如下问题：</p><p><strong>最小顶标和问题</strong>：给定二分图，给每个点一个顶标，使得每条边两端点的顶标和不小于边权，且所有点顶标和最小。</p><blockquote><p>$w_i \ge 0$，如果 $ \exists w_i &lt; 0$ 那么就不能使用这种做法，不满足线性规划的条件。</p><p>如果对于每个点加入一个极大权值，需要满足最大匹配是完美匹配。</p></blockquote><p>先讲述如何将最大权匹配转化成最大权完美匹配、</p><ul><li>如果要求 $w_i \ge 0$ 的<strong>最大权匹配</strong>，那么我们只需要将所有不存在的边视作边权为 $0$ 的边，如果左右两部点数不相等就补位相等。</li><li>如果要求<strong>存在</strong> $w_i &lt; 0$ 的最大权<strong>完美</strong>匹配，就将不存在的边权值设为 $- \infty$。</li><li>如果要求<strong>存在</strong> $w_i &lt; 0$ 的最大权匹配，那么当然是把所有负权边删掉，变成非负的情况。</li></ul><p>我们将左边点顶标称为 $A_i$ 右部点 $j$ 的顶标称为 $B_j$，我们要求 $A_i + B_j \ge d(i, j)$，其中 $d(i, j)$ 为 $i, j$ 之间的边权。</p><p><strong>相等子图：</strong>所有满足 $A_i + B_j &#x3D; d(i, j)$ 的边构成的子图。</p><p><strong>命题</strong>：相等子图中若存在完美匹配，那么这组完美匹配是原图的一个最大权完美匹配。</p><p>证明：对于边权和显然是 $\sum A_i + \sum B_j$，那么对于原图中任意的一组完美匹配有 $d(i, j) \le A_i + B_j$ 所以取到最大边权和。</p><p>如果相等子图中没有完美匹配，考虑调整法。</p><p>假设左侧有点 $x$ 在相等子图的最大匹配中是非匹配点，让 $x$ 尝试找增广路（虽然是没有的）考虑对于左边的顶标减少 $\Delta$ 右边增加 $\Delta$。</p><ul><li>匹配边，两边要么都能访问到，要么都不能访问到，还是属于相等子图。</li><li>对于某个以访问到的左端点为一端的非匹配边，由于 $A_i$ 减小，有可能加入相等子图中。</li></ul><p>我们取 $\Delta &#x3D; \min(A_i + B_j - d(i, j))$ 即可，这样至少加了一条边。</p><p><strong>优化</strong>：$\tt Slack$ 优化的基于 $\tt Bfs$ 的 $\tt KM$ 算法。</p><ul><li>每次尝试增广的时候模拟匈牙利算法求增广路的过程，对于右边的每个点 $y$，记录 $\tt Slack_y$ 表示这一轮已经访问的左侧点 $x$ 中，$\min(A_x+B_y-d(x, y))$。</li><li>当我们访问一个左部点的时候，先用其更新右部点的 $\tt Slack$ 值，接下来取出右部 $\tt Slack$ 最小的点，将其值设为 $\Delta$，之后修改左右部分的所有点，并且更新 $\tt Slack$ 数组。</li></ul><blockquote><p>也就是 $\tt Slack$ 数组减去 $\Delta$。</p></blockquote><ul><li>将下一个访问的左部点设为取出的右部点的匹配点，如果没有被匹配那就找到了一条增广路。</li><li>重复上述过程，得到最大权完美匹配。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line"><span class="keyword">const</span> int64 inf = <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, mt[maxn], pre[maxn];</span><br><span class="line">int64 ex[maxn], ey[maxn], sl[maxn], vc[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">yy</span>(<span class="number">0</span>), i; int64 tmp;</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) sl[i] = inf;</span><br><span class="line">    mt[y] = u;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        x = mt[y], tmp = inf, vis[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sl[i] &gt; ex[x] + ey[i] - vc[x][i]) &#123;</span><br><span class="line">                sl[i] = ex[x] + ey[i] - vc[x][i];</span><br><span class="line">                pre[i] = y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sl[i] &lt; tmp) tmp = sl[i], yy = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]) ex[mt[i]] -= tmp, ey[i] += tmp;</span><br><span class="line">            <span class="keyword">else</span> sl[i] -= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        y = yy;</span><br><span class="line">        <span class="keyword">if</span>(mt[y] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y) mt[y] = mt[pre[y]], y = pre[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int64 <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ex, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ex));</span><br><span class="line">    <span class="built_in">memset</span>(ey, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ey));</span><br><span class="line">    <span class="built_in">memset</span>(mt, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">bfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">int64 <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span>(mt[i] != <span class="number">-1</span>)</span><br><span class="line">        res += vc[mt[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++ j) vc[i][j] = - inf;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; int64 w;</span><br><span class="line">        <span class="built_in">r1</span>(u, v, w), vc[u][v] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">KM</span>());</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, mt[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例题 $7$：$\text{[UVA 1411] Ants}$</p><p>给定平面上 $n$ 个黑点和 $n$ 个白点，请选 $n$ 条线段，每条线段连接一个白点和黑点，每个点只作为一条线段的端点，且这些线段两两不交。</p><p>一定存在解。</p></blockquote><p>考虑线段两两不交的限制，也就是考虑若 $AB \cap CD \neq \emptyset$，那么有 $AB+ CD &gt; AD + BC$，因为一定存在解，所以考虑不相交的线段肯定是边权和最小的。</p><p>也就是求连接黑点和白点的长度和最小的 $n$ 条线段对应的匹配，直接执行 $\tt KM$ 算法。</p><h3 id="tt-Hall-定理"><a href="#tt-Hall-定理" class="headerlink" title="$\tt Hall$ 定理"></a>$\tt Hall$ 定理</h3><p>对于二分图 $G &#x3D; (V, E)$ 另 $N(v)$ 表示与 $v$ 相邻的点集，则关于最大匹配，我们有如下结论：</p><p><strong>定理</strong>：设二分图的两部分为 $X, Y$ 且 $|X| \le |Y|$，则其存在一个大小为 $|X|$ 的匹配，当且仅当 $\forall S \subseteq X$，有 $|S| \le |\bigcup_{v \in S} N(v)|$。</p><blockquote><p>就是说其能到达的点集 $V \subseteq Y, |S| \le |V|$。</p></blockquote><p>证明：</p><p>必要性：若存在 $S$ 使得条件不成立，所有点的匹配点形成了一个大小不小于 $|S|$ 的点集，其中肯定存在一个子集的大小大于超集。</p><p>充分性：若条件成立但是不存在大小为 $|X|$ 的匹配，考虑从左部点开始尝试增广，因为匹配不成功所以递归终止点必然是<strong>左部点</strong>，考虑遍历到的所有左部点有 $|L|&#x3D; |R| + 1$ 与条件矛盾。</p><p><strong>推论1：</strong>若一个无向图的每个点度数都为 $k$，则成其为 $k$ 正则图，那么左右点数相等的 $k$ 正则二分图必有完美匹配 （$k \ge 1$）。</p><blockquote><p>证明：反证法，设存在左部点集 $L$ 设其邻居并为 $R$ 有 $|L| &gt; |R|$，那么 $R$ 中所有点的度数和不小于 $k \times |L|$。但是 $R$ 的大小 $&lt; L$ 是不可能的。</p></blockquote><p><strong>推论2：</strong> 如果点带权，左部点 $i$ 需要匹配 $a_i$ 个右部点（可重复），而右部点 $i$ 可匹配 $b_i$ 个左部点（可重复），我们将定理中的 $|S|$ 和 $|\bigcup_{v \in S} N(v)|$ 改成其元素和即可。</p><h3 id="tt-Hall-定理推广"><a href="#tt-Hall-定理推广" class="headerlink" title="$\tt Hall$ 定理推广"></a>$\tt Hall$ 定理推广</h3><p><strong>定理：</strong>设二分图 $G$ 的两部分是 $X,Y$，则其最大匹配为 $|X| - \max(|S| - |\bigcup_{v \in S} N(v)|)$，其中 $S \in X$。</p><p>证明：</p><p>令 $f(S) &#x3D; |S| - |\bigcup_{v \in S}N(v)|$。</p><p>首先最大匹配不会超过 $|X| - f(S)$，考虑 $f(S)$ 取到最大值的 $S$，其点的总匹配数不会超过 $|\bigcup_{v \in S} N(v)|$。</p><p>所以整张图的最大匹配数不会超过 $|X| - \max(f(S))$。</p><blockquote><p>我们感性理解一下， 就是考虑一个集合其最大的不能匹配的点数是 $\max(f(S))$，就算剩下的点都能进行匹配，那么就是 $|X| - f(S)$。</p></blockquote><p>考虑如果最大匹配小于这个数，从左部的非匹配点进行增广，对于所有递归过程构成了以左部点<strong>非匹配点</strong>为根，所有叶子为左部点的森林，设左部非匹配点有 $s$ 个，不妨设左右点数分别为 $l, r$，满足 $l &#x3D; r + s$，因为 $s$ 是一个 $f(S)$，所以左部非匹配点不超过 $\max(f(S))$ 个。</p><blockquote><p>例题 $8$：</p><p>给定左部 $n$ 个点，右部 $m$ 个点的二分图，左部点 $i$ 向右部 $[l_i, r_i]$ 内的所有点连边，求是否存在大小为 $n$ 的匹配。</p></blockquote><blockquote><p>$\tt Hall$ 定理就是求匹配的存在性。</p></blockquote><p>也就是判断条件：$\forall S \subseteq X, |S| \le \bigcup_{v \in S} N(v)$ 是否成立。</p><p>首先考虑一手按照区间进行排序，那么我们最终选择的肯定是连续的排序之后连续的左部点。</p><blockquote><p>如果区间重合很好处理，如果不重合呢？</p></blockquote><p>如果区间有重合可以考虑式子能直接使用线段树查询，如果区间不重合，考虑先求出每个重合区间的答案。</p><p>发现如果每个子区间合法那么合并这个两个区间肯定合法。</p><blockquote><p>对啦！！！</p></blockquote><p>考虑当不存在大小为 $n$ 的匹配是，一定存在一个区间作为 $R$ 使得 $\tt Hall$ 定理的条件不成立，不妨设区间为 $[l, r]$ 要算出左部点满足 $[l_i, r_i] \subseteq [l, r]$ 的 $i$ 个数，减去 $r - l + 1$ 之后取 $\tt max$。</p><p>使用数据结构维护这一过程，升序扫描 $r$，对于每个 $l$ 维护当前 $[l, r]$ 对应的 $|L| - |R|$，当 $r$ 增大时如果有 $r_i &#x3D; r$ 的左部点 $i$，则需要将 $l \le l_i$ 的所有 $l$ 对应的 $|L|-|R|$ 增大 $1$，然后每次询问全局最大值如果存在正值就不存在大小为 $n$ 的匹配。</p><blockquote><p>首先升序枚举 $r$ 肯定是所有点都加入进去的，然后我们只需要考虑线段树维护重复的贡献，我们不需要考虑线段树的 $l$ 是否真的存在，因为对于真实存在的点 $l$ 取到的肯定是最值。</p><p>所以直接一起维护即可。</p></blockquote><p>我们接下来继续分析这张图匹配的特性。</p><p>将所有左部点按照 $r_i$ 从小到大排序，考虑第一个左部点 $x$ 应该匹配哪个右部点。</p><p>根据 $\tt hall$ 定理，设左部点集为 $V_L$，对于 $A \subseteq V_L$ 且 $x \not \in A$，我们希望删除 $x$ 及其匹配点之后对 $\bigcup_{v \in S} N(v)$ 影响最小，也就是尽量使其不变。</p><p>也就是尽量使其不变，因为第一个点的限制我们有 $r_x \le r_i$，所以选择取 $l_x$，如果只有单个点对于 $A \cup x$ 来说是会更优的，不然是不变的。</p><p>我们贪心撇皮每次选择当前可以匹配点中最靠前的一个没有被匹配过的点，若每个点都被匹配，那么就找到了一个大小为 $n$ 的匹配。</p><p>这启发我们：<strong>Hall 定理可以作为一些显式或隐式匹配问题的贪心策略依据。</strong></p><blockquote><p>例题 $9$：</p><p>给定左部 $n$ 个点，右部 $m$ 个点的二分图，左部点 $i$ 向右部 $[1, l_i] \cup [r_i, m]$ 内的所有点进行连边，求最大匹配。</p></blockquote><p>也就是求 $n - \max(|S| - \bigcup_{v \in S} N(v))$。</p><p>如果前缀是递增的，我们考虑选择 $i$ 那么前缀的部分肯定没有用了，对于后缀我们可以维护 $i - 1$ 的区间答案每次加入一个区间的时候使用区间加。</p><p>之后分类讨论如果点 $i$ 的后缀是最大的，那么就是查询 $r$ 小于当前值的贡献，不然考虑加入当前值求最优贡献。</p><p>复杂度是 $O((n + m)\log m)$  的。</p><p>枚举左部点集 $L$ 其右部点邻居集 $R$ 必然是一段前缀并后缀。</p><p>考虑枚举 $R &#x3D; [1, l] \cup [r, n]$，同上题可以得到关于 $L$ 中的点的 $l_i, r_i$ 的限制，使用数据结构升序扫描 $l$，对于每个 $r$ 维护 $|L| - |R|$，当 $l$ 增加是若遇到 $l_i &#x3D; l$ 的 $i$，则对于 $r \le r_i$ 的 $r$，其 $|L| - |R|$ 将增大 $1$。</p><blockquote><p>例题 $10$：</p><p>给定左部 $n$ 个点，右部 $m$ 个点的二分图，左部有点权 $a_i, b_i$，右部点有点权 $c_j, d_j$，且 $(i, j)$ 之间有边当且仅当 $a_i \ge d_j$ 或者 $c_j \ge b_i$ 求最大匹配。</p></blockquote><p>首先右部点按照 $d$ 从小到大排序，左部点按照 $a$ 从小到大排序，可以发现左部点 $i$ 连接的肯定是一段前缀，之后考虑右部点。</p><p>考虑从 $0$ 开始枚举 $d$ 使用线段树维护 $c &#x3D; x$ 的答案。</p><p>当增加 $d$ 使得位置 $i$ 被加入之后，对于同时满足 $c, d$ 限制的贡献被计算了两遍，所以需要减去贡献。</p><p>复杂度是 $O((n + m) \log n)$ 。</p><h3 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h3><p>给定有向图 $G &#x3D; (V, E)$，每条边有非负容量 $c_i$，同时给定两个不同点 $s, t \in V$ 分别表示源点，汇点，则称这是一张网络图。</p><p>令 $c(u, v)$ 表示当 $u, v$ 之间有有边是等于这些边的容量和，否则等于 $0$。</p><p>定义一个合法流函数 $f:V\times V \to R$ 是满足如下性质的函数：</p><ul><li>$f(u, v) \le c(u, v)$。</li><li>$f(u, v) &#x3D; -f(v, u)$。</li><li>令 $fl_i &#x3D; \sum_{j &#x3D; 1} ^ n f(i, j)$ 有 $fl_s \ge 0, fl_t \le 0$ 对于其他点都有 $fl_i &#x3D; 0$。</li></ul><blockquote><ol><li>流量上限。</li><li>流量方向。</li><li>除了 $s, t$ 外每个点都不存储流，所有流入的流量都会流出。</li></ol></blockquote><p>最大流问题就是对于给定网络图找出了一个合法的流函数，使得 $fl_s$ （称为流量）最大。</p><p><strong>基本性质：</strong></p><ul><li>$fl_s &#x3D; - fl_t$。</li><li>若不存在 $i \to j$ 和 $j \to i$ 的边，则必有 $f(i, j) &#x3D; f(j, i) &#x3D; 0$，这是因为 $c(i, j) &#x3D; c(j, i) &#x3D; 0$。</li></ul><p>根据性质 $2$ 我们只需要记录边的点对之间的流，或者说只需要记录每条边上运载的流的大小。</p><p>$\tt Dinic$ 算法：</p><p>先确定一个任意的初始流函数，比如所有 $f(i, j) &#x3D; 0$，随后不断尝试扩大最大流。</p><p><strong>残量网络</strong>：设当前已有一个流函数 $f$，则取 $c’(i, j) &#x3D; c(i, j) - f(i, j)$ 为个条边容量得到的新的网络图。</p><p><strong>增广路</strong>：我们任取一条 $s \to t$ 的路径 $v_1 \to \cdots \to v_n(v_1 &#x3D; 1, v_n &#x3D; t)$ 使得 $c’(v_i, v_{i + 1}) &gt; 0$。</p><p>最大流算法都用到一个<strong>重要性质：当前函数是最大流，当且仅当参量网络不存在增广路</strong>。</p><p>暴力思路就是暴力找增广路，因为流量有限所以算法肯定会在有限次增广后结束。</p><p>$\tt Dinic$ 进行了优化，首先对于参量网络进行分层，然后增广的时候只保留出发点的层数比终点层数恰好小 $1$ 的边，显然是一个 $\tt DAG$。</p><p><strong>优势：</strong>多路增广，增广使用 $\tt dfs$，分层使用 $\tt bfs$。</p><blockquote><p>当前弧优化可以保证每条边用完之后就不会再遍历到。</p></blockquote><p>最大流可以解决二分图最大匹配问题：建立源汇点 $s, t$ 从 $s$ 向所有左部点连接容量为 $1$ 的边，汇点对右部点连接容量为 $1$ 的边。</p><blockquote><p>比匈牙利算法要快。</p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P3305">[SDOI2013]费用流</a></p><p>给定网络图，$\tt Alice$ 需要给出一个最大流对应的流函数，随后$\tt Bob$ 可以给每条边赋予非负费用 $c_i$，要求所有边费用总和为 $P$，使得 $\tt Alice$ 的最大流中所有边的流量乘费用求和最大，$\tt Alice$ 希望这个最大值最小，求这个最大值的最小值。</p></blockquote><p>考虑 $\tt B$ 的策略是啥，就是选择流量最大的边，让其费用为 $P$。</p><p>可以发现这样肯定是最优的。</p><blockquote><p>反证法：如果有两条边流量分别为 $a, b, a &gt; b$，然后费用为 $c, P - c$，贡献是 $ac + bP - bc$。和 $aP$ 相比会小很多，所以不合法。</p></blockquote><p>那么考虑如何通过一些方法让最大边权最小，直接二分答案之后求最大流即可。</p><blockquote><p>二分答案我们每条边边权对其取 $\tt min$。</p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P2891"> [USACO07OPEN]Dining G</a></p><p>有 $n$ 头牛，$f$ 种食物和 $d$ 种饮料，每种食物和饮料只有一份，每头牛有一些喜欢的食物和饮料，求最多有多少头牛可以得到自己喜欢的食物和饮料。</p></blockquote><p>考虑左边放食物右边放饮料，每头牛拆点连边。</p><p>最大流问题还可以用于解决一些其他模型。</p><h4 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h4><p>对于有向图 $G$，每条边有非负代价 $c_i$，求删除代价最小的边集使得 $s$ 到 $t$ 不连通。</p><p><strong>定理：</strong>最小割等于将每条边的代价转化成其容量后 $s$ 至 $t$ 的最大流。</p><p>证明：</p><p>首先我们只需要考虑 $s$ 能到达或者能到达 $t$ 的点。</p><p>我们定义一组割为将 $V$ 拆成两个不相交的子集 $L, R$ 其中 $s \in L, t \in R$，我们删除所有 $L, R$ 之间的边。显然这是一组割，将这样的割称为 $C(L, R)$。</p><ol><li>对于 $G$ 中任意的合法流函数，其中 $fl_s$ 不超过 $G$ 的最小割。</li></ol><p>考虑 $L$ 中所有点的 $fl$ 之和，首先是等于 $fl_s$ 同时也是所有 $L \to R$ 的边的容量和。</p><ol start="2"><li>最大流对应的参量网络中无增广路。</li><li>若有一个流对应了无增广路的参量网络，则他也对应了一个不超过其 $fl_s$ 的割。</li></ol><p>考虑将 $L$ 设为残量网络中 $s$ 可以到达的点集，剩下点放到 $R$ 中，显然中间的边都是满流的，所以 $fl_s$ 不小于这组割。</p><p>所以这个流的流量恰好等于割的大小。</p><p>由此我们证明下面三个命题等价：</p><ul><li>$G$ 中存在一组割 $C(L, R)$ 等于 $G$ 中合法流函数 $f$ 的流量。</li><li>$G$ 中的流函数 $f$ 是最大流。</li><li>$G$ 中关于 $f$ 的残量网络是无增广路的。</li></ul><p>同时我们还可以得到刚才的一个结论：无增广路的残量网络必然对应最大流。</p><blockquote><p>首先必要性显然，根据我们之前证明的最大流等于最小割，而最小割的残量网络是无增广路的。</p></blockquote><p>我们刚刚解决的是有源汇的最小割，对于无源汇的最小割有算法 $\tt Stoer-Wagner$ 可以在 $O(VE + V^2 \log V)$ 解决该问题。</p><h4 id="无源汇的最小割"><a href="#无源汇的最小割" class="headerlink" title="无源汇的最小割"></a>无源汇的最小割</h4><p>考虑暴力就是枚举所有的源点和汇点，进行最小割。</p><p>显然对于图中 $a, b$ 两点其要么在同一个连通块要么处于不同连通块。</p><ul><li>$a, b$ 在同一连通块。</li></ul><p>显然如果 $a$ 与 $j$ 是不连通的，可以推出 $b$ 与 $j$ 是不连通的，我们可以将 $a, b$ 看成同一个点进行处理。</p><ul><li>$a, b$ 在不同连通块、</li></ul><p>构造过程开始于一个集合 $A$，初始是 $A &#x3D; \emptyset$。我们将所有点按照一个权值 $w(i)$ 从大到小加入。</p><p>令 $w(i) &#x3D; \sum_{j \in A} d(j, i)$ 其中 $d(j, i)$ 表示 $i, j$ 之间的边权。</p><p>设 $ord(i)$ 表示点 $i$ 加入集合的顺序，我们可以得到对于任意点 $s$，$s$ 到 $t$ 的最小割即为 $w(t)$。</p><p>证明：</p><p>若点 $v$ 满足在割去 $C$ 的图中，存在一个点 $u$，在 $v$ 之前加入 $A$，且 $u$ 和 $v$ 是不在一个连通块的，则称 $v$ 是 $\tt active$ 的。</p><p>考虑我们取最后一个节点 $t$ 的权值 $w(t)$ 作为最小割。因为割掉这些边之后图是不连通的，而且我们之前贪心得到的答案是最小的。换句话说 $w(t)$ 就是 $t$ 到之前所有节点的最小割。</p><p>对于第一个 $\tt active$ 节点 $v$，结论成立：因为 $v$ 前节点都不是 $\tt active$ 节点，所以都处于一个连通块内，所以 $v$ 与它们都不处在一连通块内，所以想要割掉 $v$ 需要断开它和之前所有点，花费是 $w(v)$。</p><p>对于 $v$ 之后的第一个 $\tt active$ 节点 $u$，有 $w(u)$ 是从 $v$ 前节点和 $v$ 到 $u$ 之间节点与 $u$ 的边构成的，对于 $v$ 前面的点有 $w(u)$ 对于这部分的贡献不超过 $w(v)$。同样道理对于 $v$ 到 $u$ 之间的节点与 $u$ 边权相加一定要出现在 $C$ 中，所以结论成立。</p><p>根据归纳法结论成立。</p><p><a href="https://www.luogu.com.cn/problem/P5632">Stoer - Wagner 算法</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">600</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], us[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn], S, T, w[maxn], ord[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(us, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(us));</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    w[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - x + <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ps</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span>(!vis[j] &amp;&amp; !us[j] &amp;&amp; w[j] &gt; w[ps]) ps = j;</span><br><span class="line">        us[ps] = <span class="number">1</span>, ord[i] = ps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span>(!vis[j] &amp;&amp; !us[j])</span><br><span class="line">            w[j] += d[j][ps];</span><br><span class="line">    &#125;</span><br><span class="line">    S = ord[n - x], T = ord[n - x + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> w[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, <span class="built_in">res</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">Solve1</span>(i));</span><br><span class="line">        vis[T] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            d[S][j] += d[T][j];</span><br><span class="line">            d[j][S] += d[j][T];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">r1</span>(a, b, w);</span><br><span class="line">        d[a][b] += w, d[b][a] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Solve</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.luogu.com.cn/problem/P1345">[USACO 5.4] Telecowmunication</a></p><p>给定无向图 $G$ 和点 $s, t$，求最少删除多少个非 $s, t$ 的点可以使得 $s$ 到 $t$ 不连通。</p></blockquote><p>拆点最小割。</p><blockquote><p>如果一条边不能被割的话，就将代价设为 $+\infty$。</p></blockquote><h4 id="最大权闭合子图问题"><a href="#最大权闭合子图问题" class="headerlink" title="最大权闭合子图问题"></a>最大权闭合子图问题</h4><p>给定有向图 $G$，每个点有可负点权 $a_i$，选出点集的子集 $A$，满足若 $u \in A,(u, v) \in E$ 则 $v \in A$。求 $\sum_{u \in A} a_u$ 的最大值。</p><p>考虑求的是最大值，那么如果一个点连边了一个正值点，那么这两个点肯定都入选，所以我们对于一个点需要考虑的就是能够到达的负权点。</p><p>选择一个点权为负的点相当于吧答案减掉它的权值，可以理解成我们需要舍弃这个点的权值。</p><p>因此我们将问题转化成了类似二分图的问题：将点权非负的点向它能到达的所有点权为负的点连边，再从 $s$ 向点权非负的点分别连边，点前为负的点向 $t$ 连边。</p><blockquote><p>$S$ 连接的是边权和 $T$ 连接的是边权的绝对值。</p><p>答案就是正权点 $-$ 最小割。</p></blockquote><p>就是我们考虑构建的时候权值为负的点是需要减去的，权值为正的点不选也是需要减去的。考虑我们选择一个正权点，肯定会带来其周围的负权点的贡献，显然我们不会考虑直接选择一个负权点。</p><p>所以我们只需要考虑选择正权点的贡献，使用最小割求出选择最小的权值减去。</p><p>也就是如果该限制被选择了那么其限制的点应该全部被选择。</p><h4 id="最大流方案"><a href="#最大流方案" class="headerlink" title="最大流方案"></a>最大流方案</h4><p>可以直接算出每条边的流量。</p><h4 id="最小割方案与可行边必经边"><a href="#最小割方案与可行边必经边" class="headerlink" title="最小割方案与可行边必经边"></a>最小割方案与可行边必经边</h4><p>对于最小割的方案，我们再跑完最大流之后求出 $s$ 能到达的所有点集合 $L$ 和其他点构成的集合 $R$，对于边 $(u, v)$ 如果 $u \in L$ 而且 $v \in R$ 那么边 $(u, v)$ 就在最小割中。</p><p><strong>可行边：</strong>存在一种最小割使得这条边被割断。</p><p><strong>必经边：</strong>每个最小割这条边都被割断。</p><blockquote><p>暴力：</p><ul><li>可行边：考虑删除这条边，图的最小割减少了 $w$。</li><li>必经边：将这条边代价改为 $+ \infty$ 图的最小割变大。</li></ul><p>事实上只需要判断必经边就行了。</p></blockquote><p><strong>命题：</strong>一条边 $(u, v, w)$ 是最小割可行边，当且仅当这条边满流，并且 $G’$ 上不存在 $u \to v$ 的路径。</p><p>证明：</p><p>满流显然，如果存在 $u \to s \to t \to v$ 的路径那么删除掉之后最小割不会减少 $w$，不然最小割会恰好减少 $w$。</p><p><strong>命题：</strong>一条边 $(u, v, w)$ 是最小割必经边，当且仅当这条边满流，并且 $G’$ 上存在 $s \to u$ 和 $v \to t$ 的路径。</p><p>证明：</p><p>满流显然，如果不存在 $s \to u$ 的路径，那么就算加大该边的容量最大流也不会变大，$v \to t$ 同理。</p><p><strong>定理：</strong>将 $G’$ 进行 $scc$ 缩点，则边 $(u, v,w)$ 是<strong>可行边</strong>当且仅当满流且 $u, v$ 在不同的强连通分量。是<strong>必经边</strong>当且仅当 $s, u$ 在同一强连通分量，$v, t$ 在同一强连通分量。</p><p>所以将 $G’$ 缩点得到的 $\tt DAG$ 连接不同的 $scc$ 的满流边是可行边，从 $s$ 所在 $scc$ 连接 $t$ 所在 $scc$ 的满流边是必经边，而从 $s$ 所在 $scc$ 连出去的边构成了最小割的一种方案。</p><h4 id="二分图最大匹配方案与可行点和必经点"><a href="#二分图最大匹配方案与可行点和必经点" class="headerlink" title="二分图最大匹配方案与可行点和必经点"></a>二分图最大匹配方案与可行点和必经点</h4><p>因为是拆点所以我们就说成可行边和必经边了。</p><p><strong>半增广路定义</strong>：一条路径依次通过非匹配边和匹配边，首尾分别是匹配边和非匹配边，并且终点是非匹配点。</p><p><strong>增广环定义：</strong>一个环依次经过非匹配边和匹配边。</p><p>显然对于半增广路和增广环的边取反可以得到一个新的最大匹配。</p><p><strong>定理：</strong>对于任意两组最大匹配 $P_1, P_2$ 总存在一种方法使得进行若干次取反半增广路或取反增广环的操作，使 $P_1$ 变成 $P_2$。</p><p>证明：显然不会出现两条单链不重复而且有交的情况，如果出现的话这个就不是最大匹配。那么对于单链是可以通过翻转解决的。</p><p>考虑链连接一个环的情况，也是同理。</p><p>对于这样两个匹配对于奇链肯定是相同的方案数的，所以只有偶链和环也就是半增广路和环。</p><p><strong>命题：</strong>边 $(u, v)$ 是二分图最大匹配的<strong>可行边</strong>，当且仅当 $(u, v)$ 属于当前最大匹配或存在一条经过 $(u, v)$ 的半增广路或增广环。</p><blockquote><p>显然。</p></blockquote><p><strong>命题：</strong>边 $(u, v)$ 是二分图最大匹配的必经边，当且仅当 $(u, v)$ 属于当前最大匹配且不存在一条经过 $(u, v)$ 的半增广路或增广环。</p><blockquote><p>显然。</p></blockquote><p>考虑将<strong>半增广路</strong>也转换成<strong>增广环</strong>，建立网络图：</p><ul><li>建立源点 $s$ 和汇点 $t$，从 $s$ 向左部非匹配点连边，左部匹配点向 $s$ 连边。从 $t$ 向右匹配点连边，右部非匹配点向 $t$ 连边。</li><li>对于原二分图中的边，如果属于当前最大匹配，就从右部点连向左部点，否则就从左部点连向右部点。</li></ul><p>本质上就是保留原来的增广环，对于半增广路我们需要用一种方法变成环，不妨考虑钦定原图上的匹配边是由右部点向左部点连接的，那么对于一条半增广路，如果其起点在右部点。其终点肯定也是在右部点，且起点是匹配点，终点是非匹配点。我们让右部的非匹配点向 $t$ 连边，$t$ 向匹配点连边。就转化成环了。</p><blockquote><p>另外一边同理。</p></blockquote><p>显然对于不经过 $s, t$ 的环就是增广环。</p><p>对于新的有向图 $G’$，包含一条边的增广路或增广环等价于边的两点在同一 $\tt scc$ 中。</p><p><strong>定理：</strong>边 $(u, v)$ 是二分图最大匹配的可行边，当且仅当它属于当前匹配或 $u, v$ 属于 $G’$ 中同一 $\tt scc$。而 $(u, v)$ 是二分图最大匹配的必经边，当且仅当它属于当前匹配，而且 $(u, v)$ 不属于 $G’$ 中同一 $\tt scc$。</p><p>$\tt Bonus:$ 二分图匹配最大可行点？</p><p>任何度数不为 $0$ 的点都是可行点，其出边能找到长度至少为 $2$ 的半增广路。</p><p>$\tt Bonus:$ 二分图最大匹配必经点？</p><p>不存在这个点为端点的半增广路，也就是其和 $s$ 不属于同一强连通分量。</p><h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>给定一张网络图，每段点除容量 $c(u, v)$ 外还有价值函数 $w(u, v)$ 求一个就函数 $f(u, v)$ 使得源点流量最大的情况下，$\sum w(u, v ) \times f(u, v)$ 最小，这个问题被称为<strong>最小费用最大流</strong>，简称<strong>费用流</strong>。</p><p>请注意，我们下面讨论的是<strong>价值函数不构成负圈</strong>的网络图上的费用流问题，而有负圈的情形将在介绍上下界网络流后说明。</p><p><strong>残量网络的定义</strong>：残量网络每条反向边价值为正向边的相反数。</p><blockquote><p>反悔的定义。</p></blockquote><p>令 $F_i$ 表示流大小为 $i$ 的最小费用，我们考虑如下算法：</p><ul><li>$F_0 &#x3D; 0$。</li><li>在第 $i$ 轮，以价值为边权，找出当前残量网络上 $s \to t$ 的最短路，将其附上 $1$ 的流，并让 $F_{i + 1} &#x3D; F_i + l$ 其中 $l$ 表示为路径上所有边的价值和。</li></ul><blockquote><p>证明：如果存在更小的费用 $F_n’$，我们已知 $F_{n - 1}$ 增广了最优的增广路，但是有更小的价值肯定是存在负环，显然对于这个负环我们肯定是可以提前增广的。那么 $F_{n - 1}$ 就不是最优的，与假设矛盾。</p></blockquote><p><strong>命题</strong>：在 $F_i$ 的残量网络找到最短路，若路上所有边的最小容量大于 $1$，则 $F_{i + 1}$ 的残量网络上该路径也是最短路。</p><p>证明：</p><p>假设不是，那么 $F_{i + 1}$ 的残量网络最短路肯定经过了一条这条路径上边的反向边。</p><p>设其中第一条这样的反向边为 $u \to v$，价值为 $w$，那么我们对于 $F_{i + 1}$ 最短路的 $s \to u$ 价值和为 $w_1$ 经过了 $-w$ 到达了 $v$，对于 $F_i$ 中的最短路 $s \to v$ 价值为 $w_2$ 我们有 $w_1 - w &lt; w_2$ 也就是 $w_1 &lt; w_2 + w$ 那么这个就不是最短路，与假设矛盾。</p><p>所以我们可以直接通过最短路求解，通过 $\tt johnson$ 可以直接使用 $\tt Dijkstra$。</p><blockquote><p>复杂度是 $O(n(n+m)\log n)$ 当然如果使用配对堆的话可以做到 $O(n^2\log n + nm)$。</p></blockquote><p>上述的费用流算法成为 $\tt SSP(Successive\ Shortest \ Path)$ 算法，该算法不仅可以求出最大流时的最小，而且可以求出流量依次为 $0, 1,\cdots,f$ 的最小费用，但是前提是<strong>无负环</strong>。</p><p>当要求最大费用的时候需要将边权取反来求最小费用，而存在负环的最小费用流可以利用上下界网络流解决。</p><p>费用流可以解决二分图最大权最大匹配。</p><blockquote><p>但是比 $\tt KM$ 要慢，其可以求解大小为 $i$ 的匹配的最大权值。</p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P2604">P2604 [ZJOI2010]网络扩容</a> 第二问。</p><p>给定一个网络图，每条边有费用 $w(u, v)$，表示让 $u \to v$ 的容量加 $1$ 需要付出 $w(u, v)$ 的代价，使求得 $1 \to n$ 最大流增大 $k$ 的最小代价。</p></blockquote><p>我们先算出最大流的费用，之后建立新的源点向 $1$ 连边容量为 $f+ k$，之后每条边改为 $(u, v, +\infty, w)$。</p><h4 id="模拟费用流"><a href="#模拟费用流" class="headerlink" title="模拟费用流"></a>模拟费用流</h4><p><strong>定义</strong>：有一类费用流问题由于图的特殊性，可以使用一类特殊贪心来解决。</p><p>费用流这种每次选取一条最短路进行增广的想法让我们联想到贪心，但保证费用流正确性的是其反悔机制——反向边用于退掉之前更劣的流，因此我们考虑在贪心中也贯彻这一点。</p><p>这个东西我们之后再讲，先学后面的。</p><h4 id="上下界网络流"><a href="#上下界网络流" class="headerlink" title="上下界网络流"></a>上下界网络流</h4><p>现在将网络图的定义做一些调整，除了流量上线（容量）$c(u, v)$ 外，每对点还存在流量下限 $b(u, v)$，此时的流函数 $f(u, v)$ 还应该满足 $b(u, v) \le f(u, v) \le c(u, v)$，将这样的问题称为<strong>上下界网络流</strong>。</p><blockquote><ul><li>有无源汇。</li><li>可行流，最大流，最小流，费用流。</li></ul></blockquote><h4 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a>无源汇上下界可行流</h4><p>最基础的问题 ：给定一张上下界网络图，求一种合法的流量函数，使得每个点都满足流量守恒。</p><p>考虑将问题转化成没有下界的网络流。</p><p>首先强制每条边流到下界，也就是 $f’(u, v) &#x3D; b(u, v)$ 令 $c’(u, v) &#x3D; c(u, v) - b(u, v)$，这个时候一个点的流量差为 $f(u) &#x3D; \sum b(u, i) - \sum b(i, u)$，然而这可能是不满足流量守恒的。</p><p>对于一个 $f(u) &gt; 0$ 的点 $u$ 其出流量太多了，所以需要大小为 $f(u)$ 的入流量来抵消他，就让 $u$ 向外界连一条流量恰好为 $f(u)$ 的边。</p><p>同理对于 $f(u) &lt; 0$ 的点，同样要让外界向 $u$ 连接一条流量为 $-f(u)$ 的边。</p><p>建立超级源点和超级汇点，剩下的边的容量设为 $c’(u, v) &#x3D; c(u, v) -b(u, v)$。</p><p>根据 $\sum f(u) &#x3D; 0$ 可以知道 $S$ 的出容量等于 $T$ 的如容量，只有这些边全部满流才满足流量守恒，所以如果最大流恰好等于 $F$ 说明可行流存在，且残量网络的容量就是 $c(u, v) - f(u, v)$ 的值。不然可行流就不存在。</p><h4 id="有源汇上下界可行流"><a href="#有源汇上下界可行流" class="headerlink" title="有源汇上下界可行流"></a>有源汇上下界可行流</h4><p>考虑转化成上一个问题，有源汇本质上就是可以满足 $f(s) &gt; 0, f(t) &lt; 0$ 显然对于合法的流我们有 $f(s) &#x3D; -f(t)$。</p><p>那么我们让 $t$ 向 $s$ 连接一条流量为 $+\infty$ 即可。</p><blockquote><p>本质上就是源汇之间有流交换，可以保证流量平衡。</p></blockquote><h4 id="有源汇上下界最大流"><a href="#有源汇上下界最大流" class="headerlink" title="有源汇上下界最大流"></a>有源汇上下界最大流</h4><p>先保证可行流。</p><p>记录 $t \to s$ 边的流量，这个就是当前 $s \to t$ 的流量。</p><p>因为已经满流了，所以我们只需要在参量网络上做一次普通的 $s \to t$ 的最大流即可。</p><blockquote><p>实现的时候可以不删掉 $t \to s$ 的边。</p></blockquote><p>或者二分答案，将 $t \to s$ 边的下界设为 $m$ 看是否存在可行流。</p><h4 id="有源汇上下界最小流"><a href="#有源汇上下界最小流" class="headerlink" title="有源汇上下界最小流"></a>有源汇上下界最小流</h4><p>保证可行流，记录 $s \to t$ 的流量。</p><p>考虑我们原来求最大流就是不断从 $s$ 到 $t$ 找增广路，选择只是反过来不断退增广路。</p><p>所以本质上就是用当前流量减去参量网络上 $t \to s$ 的最大流。</p><h4 id="无源汇上下界最小费用可行流"><a href="#无源汇上下界最小费用可行流" class="headerlink" title="无源汇上下界最小费用可行流"></a>无源汇上下界最小费用可行流</h4><p>同样建图，新增的边价值为 $0$。</p><p>将初始费用设为 $\sum b(u, v) \times w(u, v)$，然后跑 $s \to t$ 的费用流。</p><blockquote><p>流的可行性同理。</p></blockquote><h4 id="有源汇上下界最小费用流"><a href="#有源汇上下界最小费用流" class="headerlink" title="有源汇上下界最小费用流"></a>有源汇上下界最小费用流</h4><p>可行流时直接连边 $t \to s$ 变成无源汇情况。</p><p>如果是最小费用最大流本质一样，跑完 $S \to T$ 的最小费用最大流之后再跑 $s \to t$ 的。</p><p>如果是最小流就是从 $t \to s$ 跑流，退流。</p><blockquote><p>费用改成最大费用就直接取反就行了。</p></blockquote><h4 id="有负环的费用流"><a href="#有负环的费用流" class="headerlink" title="有负环的费用流"></a>有负环的费用流</h4><p>对于一条价值为负数的边 $(u, v, c, w)$ 我们假设这条边流满，即答案费用加上 $w \times c$，然后建反边 $(v, u, c, -w)$ 用于退流，此时就全是正权边了！</p><p>但是这有一个问题，现在的 $u, v$ 可能不满足流量守恒，但是前面所说的上下界的基本思路和这里是一样的，还是建立超级源点汇点。</p><p>如果是无源汇就是 $S \to T$ 的正权费用流，如果有源汇那么就跑完 $S \to T$ 之后跑 $s \to t$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4843">P4843 清理雪道</a></p><p>给定 $DAG$ 求最少需要几条路径能覆盖所有<strong>边</strong>至少一次。</p></blockquote><p>$\tt Dilworth$ 定理是不行了，考虑转换成上下界网络流。</p><p>考虑边覆盖那么流至少为 $1$，之后让 $s$ 向所有点连边 $[0, +\infty]$，所有点向 $t$ 连边 $[0, +\infty]$。</p><p><strong>重点：</strong>将覆盖转化成流量下界。</p><h3 id="网络流扩展与建模举例"><a href="#网络流扩展与建模举例" class="headerlink" title="网络流扩展与建模举例"></a>网络流扩展与建模举例</h3><p>常见想法与转化：</p><ul><li><p>多源问题：</p><p>  如果一道题中有多个可行的原点$s_1, \cdots, s_a$ 和多个可行的汇点 $t_1, \cdots, t_b$，那么我们可以建立超级源汇 $S, T$，从 $S$ 向 $s_i$ 连容量无穷的边，$t_i$ 向 $T$ 连容量无穷的边， 转化成单源汇问题。</p></li><li><p>点转边：</p><p>  如果有<code>一个点只能有不超过 f 的流经过</code> 之类关于点的限制，可以拆点连入边到入点，出边到出点，入点和出点之间连接容量为 $f$ 的边。</p></li><li><p>边转点：</p><p>  有些问题中（不一定是网络流），需要将边转化成点，可以考虑为每个边新建一个点，向两端连边。</p></li><li><p>出入流量差限制：</p><p>  如果网络图中对于某些点$i$ 有其出流量减去如流量恰好等于 $f_i$，就按照上下界网络流一样的建图方法。对于 $f_i &gt; 0$ 的点让 $S$ 向它连边，不然就让它向 $T$ 连边，容量为 $- f_i$，随后要加上 $S$ 或 $T$ 相关边的满流的限制。</p></li><li><p>双选问题：</p><p>  如果一道题中某个元素有两种（或多种）可能的取值，可以先假设取其中一个代表，比如说最小值，再用流标记调整成较大的。</p></li></ul><h4 id="最大流建模"><a href="#最大流建模" class="headerlink" title="最大流建模"></a>最大流建模</h4><blockquote><p><a href="https://www.luogu.com.cn/problem/P2766">P2766 最长不下降子序列问题</a> 第二问</p><p>给出一个长度为 $n$ 的序列 $a_{1 \cdots n}$，求最多能选出几个不相交的最长不下降子序列。</p></blockquote><p>考虑分层图。</p><p>设 $f(i)$ 表示最后一个元素为 $a_i$ 的最长不下降子序列长度。</p><p>考虑怎样的子序列 $b_1,\cdots,b_m$ 是合法的：</p><ul><li>满足 $f(b_{i + 1}) &#x3D; f(b_i) + 1$ 且 $f(b_1) &#x3D; 1, m$ 恰好是最长不下降子序列长度。</li></ul><p>不妨设最长不下降子序列长度为 $s$，将所有点按照 $f(i)$分成 $s$ 类形成分层图，对于 $f(j) &#x3D; f(i) + 1$ 让 $i \to j$ 进行连边，之后拆点保证每个点的流量限制。</p><p>之后将 $S$ 向第一层点连边，最后一层点向 $T$ 连边。</p><p><strong>重点：</strong>分层图和方案数的关系。</p><blockquote><p>所以我们可以对于给定图计算起点到终点的 点 &#x2F; 边 不相交最短路的最大数量，考虑最短路 $\tt DAG$。</p><p>边的话就将边的容量设置为 $1$，连边还是类似的。</p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P3163">P3163 [CQOI2014]危桥</a></p><p>给定无向图，两个人分别要走 $2 \times a_n$ 次 $a_1 \to a_2$ 的任意路径和 $2 \times b_n$ 次 $b_1 \to b_2$ 的任意路径，某些边可以任意多次经过，某些边只能经过两次，求是否存在合法方案。</p></blockquote><p>首先很直接的想法就是两个源点汇点，这样边的限制就满足了，但是如果存在一条路径中途改变的情况。</p><p>如果两条路径有交那么我们是可以直接使其合法的。</p><p>因为第一次跑是不一定合法的，所以我们考虑能不能通过另外的方式来验证合法性，也就是判断路径的可行性。</p><p>显然我们的最大流肯定是 $2\times (a_n + b_n)$。</p><p>考虑直接建立流可能会出现 $a_1 \to b_2$ 的情况，如果说有另外的一条路径满足 $b_2 \to a_2$，那么肯定是可行的。</p><p>当然对于 $b_1 \to a_2$ 也是同理。</p><p>考虑进行跑两次流，第一次是源点为 ${a_1,b_1},$ 汇点为 ${a_2, b_2}$ ，第二次是源汇分别是 ${a_1, b_2}, {a_2, b_1}$ 。</p><p>如果两次流都是满的说明是可行的。</p><p>证明：</p><p>首先如果第一次流没有流满，直接说明连路径的个数都不满足了显然不合法。</p><p>考虑如果第二次没有流满的情况同上。</p><p>我们考虑对于满足条件是否一定能构造出来方案。</p><p>假设第一次流真实情况下 $a_1 \to a_2$ 偏少，那么我们需要 $a_1 \to b_2 \to a_2$ 来弥补。</p><p>因为第二次和第一次本质上图是没有什么变化的，所以 $b_2 \to a_2$ 的方案数恰好是缺少的部分。</p><p>对于第一次因为流总量是不变的 $a_1 \to b_2$ 肯定相对多了一些，多的部分也就是 $a_1 \to a_2$ 少的部分。</p><p>所以通过拼接是可以得出合法方案的。</p><h4 id="最小割建模"><a href="#最小割建模" class="headerlink" title="最小割建模"></a>最小割建模</h4><blockquote><p><a href="https://www.luogu.com.cn/problem/P2598">P2598 [ZJOI2009]狼和羊的故事</a></p><p>给定 $n \times m$ 网格中每个给子有狼，有羊，或者都没有的状态，求周长总和最小的一些边线，使得一头狼不经过这些变现的情况下走到任意一样处。</p></blockquote><p>羊设为源点，狼设为汇点，一条边线割断的代价为 $1$，多源汇最小割。</p><p>除此之外，考虑最小割建图时会利用其二元性质：一个点与 $s, t$ 其中一个连通。</p><h5 id="最小割模型-1-双选模型-："><a href="#最小割模型-1-双选模型-：" class="headerlink" title="最小割模型 $1$ (双选模型)："></a>最小割模型 $1$ (双选模型)：</h5><blockquote><p>有 $n$ 个物品，需要将它们分成 $A, B$ 两个集合，第 $i$ 个唯品分入 $A$ 集合的代价是 $a_i$，分入 $B$ 集合的代价为 $b_i$，对于 $i, j$ 两个物品如果它们所属集合不同则需要额外付出 $c(i, j)$ 的代价求最小总代价。</p></blockquote><blockquote><p>经典题。</p></blockquote><p>首先考虑其在 $S$ 不妨设为 $A$ 集合，如果在 $T$ 就是 $B$ 集合，单向边。</p><p>之后我们只需要考虑所属集合不同的代价，也就是两点直接连边容量为 $c(i, j)$，如果 $c(i, j) &#x3D; c(j, i)$ 直接连双向边。</p><p>点数为 $O(n)$ 边数为 $O(n +m)$ 其中 $m$ 是非零联合代价数量。</p><p><strong>变形：</strong></p><ul><li>如果一个集合最初属于其中一个集合，换到另一个集合需要代价 $d_i$，那么分入原来集合的代价就是 $0$，到另一个集合的代价就是 $d_i$，不建对应的边即可。</li><li>只有 $i$ 属于 $A$ 集合且 $j$ 属于 $B$ 集合才需要付出 $c(i, j)$ 的代价：双向边改成单向边。</li></ul><blockquote><p><a href="https://www.luogu.com.cn/problem/P2057">P2057 [SHOI2007]善意的投票 &#x2F; [JLOI2010]冠军调查</a></p><p>有 $n$ 个小朋友，每个小朋友有一个 $0&#x2F;1$ 值，要取反一个小朋友的值需要 $1$ 的代价，有 $m$ 对小朋友是好朋友，如果他们值不一样则需要付出 $1$ 代价，求最小总代价。</p></blockquote><p>值 $0&#x2F;1$ 本质上就是看其属于哪个集合，钦定 $S$ 表示集合 $0$。</p><p>套用上述做法即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4076">P4076 [SDOI2016]墙上的句子</a></p><p>题面太长了。</p></blockquote><blockquote><p>题面很强。</p></blockquote><p>注意 <code>翻转过来也是一个单词</code> 说明单词肯定是成对出现的。</p><p>首先对于行和列建点，钦定和 $S$ 连边的是正串。</p><blockquote><p>钦定正串的字典序比反串要小。</p></blockquote><p>那么首先回文串不管怎么样都是 $1$ 的贡献，所以特判掉。</p><p>对于剩下确定正反的串让其直接跟 $S$ 或者 $T$ 连边 $+\infty$。</p><p>对于正串和反串之间的贡献考虑连边 $2$ 表示同时出现。</p><p>之后考虑行列需要满足对于同样的看的方式串是有限制的。</p><p>考虑两个串的联合贡献就是一些单词的集合，我们让每行每列对于其包含的单词的起点，终点连边 $+\infty$。</p><p>因为题目保证了对于确定读法是符合条件的，我们可以先算出是全正串还是全反串。</p><p>对于全正串的部分我们将 $S$ 向其连接 $+\infty$ 否则就是其向 $T$ 连接 $+\infty$。然后对于每个行列连接单词的起点和终点。</p><p>对于没有确定的行和列我们本质上不需要连 $S, T$ 的边。</p><blockquote><p>因为这个东西可以看情况而定的，所以本质上就是 $S, T$ 都连接上一个权值为 $x$ 的边，然后 $x$ 是不产生贡献的所以 $x &#x3D; 0$。</p></blockquote><p>注意上述模型的使用限制：</p><ul><li>每个元素的决策是二元的（也就是只有 $S, T$ 连通两个选择）</li><li>联合贡献只能是<strong>两个元素</strong>之间的。</li><li>联合贡献对答案是负影响（也就是这样的贡献越少越好）。</li></ul><p>如果第二个或者第三个条件不满足则需要用到最大权闭合子图的建图方法，通常情况下点数会增大成联合权值的个数。</p><blockquote><p>可以看下面<a href="#jump1">最大权闭合子图问题</a></p></blockquote><h5 id="最小割模型-2-（串联模型）："><a href="#最小割模型-2-（串联模型）：" class="headerlink" title="最小割模型 $2$（串联模型）："></a>最小割模型 $2$（串联模型）：</h5><blockquote><p>有 $n$ 个 $[1, m]$ 中的数 $a_1, \cdots, a_n$（不是给定的），将 $a_i$ 赋值成 $j$ 需要付出 $v(i, j)$ 的代价，有 $q$ 个限制，每个限制形如 $a_x - a_y &lt; z$ （可改变不等号方向）。</p></blockquote><p>将每个点 $a_x$ 拆成 $m + 1$ 个点，第 $i$ 个点称为 $a_x(i)$，将这些点串联，其中第 $i$ 到第 $i + 1$ 个点的容量是 $v(x, i)$，并从 $s$ 向第一个点连边，最后一个点向 $t$ 连边，容量都是无穷。那么这条链上的最小割就是恰好割掉中间的一条边。</p><p>考虑限制 $a_x - a_y &lt; z$ 我们从 $a_x(i)$向 $a_y(i - z)$ 连容量为 $+\infty$ 的边，表示如果 $a_x$ 选择了 $\ge i$ 的数，$a_y$ 就不能选择 $\le i - z$ 的数。</p><p>但是可能存在一个点割掉了若干条边满足限制，所以先对约束求一遍<strong>最短路</strong>，对每一对点列建边。</p><p>或者可以考虑建边 $a_x(i + 1) \to a_x(i)$ 容量无穷，表示每个位置都需要满足之前限制的条件。</p><p>图中的点数为 $O(nm)$ 边数为 $O((n + q)m)$。</p><p>简单变形：</p><ul><li>将 $a_i$ 赋值为 $j$ 可以获得收益：先加上最大收益，再讲每个数的收益与最大收益作差作为代价。最后就是相减了。</li><li>不等号方向改变：$a_y - a_x &lt; - z$。</li></ul><blockquote><p><a href="https://www.luogu.com.cn/problem/P3227">P3227 [HNOI2013]切糕</a></p><p>给定所有 $v(x, y,z)(x \in [1, P], y \in [1, Q], z \in [1, R])$，求一组 $f(x, y)$ 使得相邻的 $(|x_1 - x_2| + |y_1 - y_2| &#x3D; 1)$ 二元组的 $f$ 值相差不超过 $D$，且所有 $v(x, y, f(x, y))$ 之和最大。</p></blockquote><p>不妨考虑重新标号我们有 $- D \le v_x - v_y \le D$ 就是上述的限制了。</p><p>之后是最小割杂题。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5039">P5039 [SHOI2010]最小生成树</a></p><p>给定无向图，每次操作可以将一条边权增大 $1$，问使得给定的边一定在此图最小生成树中至少需要先执行几次操作。</p></blockquote><p>一定存在说明考虑不大于这条边的其他边中两端点是不连通的。</p><p>本质上就是考虑删除若干条边让两端点不连通，直接最小割即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5458">P5458 [BJOI2016]水晶</a></p><p>题面较为复杂。</p></blockquote><p>首先坐标系有 $x + y + z &#x3D; 0$ 我们考虑如果让 $x’ + y’ &#x3D; 0$ 而且有 $-z’ &#x3D; x’ + y’$ 那么我们有 $x’ + y’ + z’ &#x3D; 0$ 同样也是一个合法的坐标系，可以发现这个是满射。</p><p>考虑对于坐标系进行 $\mod 3$ 染色，我们只需要考虑 $\mod 3 &#x3D; 0$ 的点进行考虑，显然如果选了三个点有 $\mod 3 &#x3D; 0, 1, 2$ 那么肯定是不合法的。</p><p>让能量源作为中间点，两种颜色作为两边点，相邻颜色进行连边，拆点最小割。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3756">P3756 [CQOI2017]老C的方块</a></p><p>题面复杂。</p></blockquote><p>发现这样奇怪的限制是很难处理的，考虑网络流题可以先考虑染色，对于长度为 $4$ 的不同限制我们可以考虑染 $4$ 种颜色。</p><p>发现都可以表示成 <code>黄蓝绿红</code> 的路径，那么我们考虑进行连边。</p><ul><li>$S \to $ 黄，边权为移除黄色的代价。</li><li>黄 $\to$ 红，边权为 $\tt inf$。</li><li>红 $\to$ 黑，边权为移除红色或黑色的最小值。</li><li>黑 $\to$ 绿，边权为 $\tt inf$。</li><li>绿 $\to T$，边权为移除绿色的代价。</li></ul><p>复杂度是 $O(C + n^2n)$ 的，但是 $\tt dinic$ 复杂度与图的深度有关所以因为图的深度很小复杂度也是对的。</p><h4 id="最大权闭合子图建模"><a href="#最大权闭合子图建模" class="headerlink" title="最大权闭合子图建模"></a>最大权闭合子图建模</h4><div id = "jump1"><div><blockquote><p><a href="https://www.luogu.com.cn/problem/P4174">P4174 [NOI2006] 最大获利</a></p><p>有 $n$ 座基站，第 $i$ 座建造代价为 $p$，还有 $m$ 个用户群，每个用户群只要基站 $a_i, b_i$ 都建了就会带来 $c_i$ 的收益，问最大净利润。</p></blockquote><p>我们只需要考虑用户群是否生效，如果该用户群生效就意味着 $(u, v)$ 一定都被选择。</p><p>考虑使用最小割解决最大权闭合子图，对于用户群和基站建点，分别是左边，右边的点。考虑左边连接的是贡献，右边连接的是代价即可。</p><blockquote><p><a href="https://darkbzoj.tk/problem/1565">[NOI2009]植物大战僵尸</a></p><p>给定一个 $n \times m$ 的矩阵，僵尸只能从右向左沿着一条直线走。</p><p>击杀某个植物会获得收益 $p_i$，$p_i$ 不一定是正数。</p><p>每个植物有攻击集合，僵尸不能走到攻击集合上，当然你可以吃掉某个植物再走。</p><p>求僵尸的最大收益。</p></blockquote><p>如果吃掉这个某个植物首先要吃掉该行之后的所有植物，还要吃掉该路径上攻击范围的所有植物才能获得贡献。</p><p>也就是意味着如果选择了该植物就必须选择其他的某些植物。</p><p>考虑如果 $x$ 守护了 $y$ 就建立边 $y \to x$ 如果 $x$ 在 $y$ 的右边也同理。</p><p>但是对于大小 $&gt; 1$ 中的强联通分量是不能选择的，我们去掉这些点，之后再跑最大权二分图匹配即可。</p><h5 id="集合联合贡献："><a href="#集合联合贡献：" class="headerlink" title="集合联合贡献："></a>集合联合贡献：</h5><blockquote><p>从 $n$ 个元素中选出一些，每个元素选择有代价，有 $m$ 个元素集合，如果某个集合中的元素全都选了就会有一个对应的收益求最大净收益。</p></blockquote><p>左部点为集合，右部点为元素。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3410">P3410 拍照</a></p><p>模板。</p></blockquote><p>有时一些贡献会比较抽象，且贡献之间可能还互相影响，需要更多边来描述：</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3749">P3749 [六省联考 2017] 寿司餐厅</a></p><p>题面复杂。</p></blockquote><p>考虑如果选择了 $[i, j]$ 那么就意味着一定需要选择 $d(l, r), i \le l \le r \le j$。</p><p>为了缩减边数我们考虑二维前缀和一样连边，只需要限制 $d(i - 1, j), d(i, j - 1)$。</p><p>对于贡献 $cx$ 可以考虑加在 $d(i, i)$ 对于 $mx^2$ 的考虑让所有 $x$ 连接他，之后连接到 $T$ 贡献是固定的。</p><p>还是最大权闭合子图。</p><hr><p>注意最小割一定是比最大权闭合子图更强的模型：例如如果在最大权闭合子图的基础上将“选一个点而不选其后继”的代价从 $+ \infty$（做不到）变为常数 $x$，只需要在构图上改变中间边的边权即可，可以用最小割模型解释。</p><p>或者说可以先尝试使用最大权闭合子图建立模型，之后通过最小割来调整。</p><h4 id="费用流与上下界网络流建模"><a href="#费用流与上下界网络流建模" class="headerlink" title="费用流与上下界网络流建模"></a>费用流与上下界网络流建模</h4><h4 id="区间选择模型："><a href="#区间选择模型：" class="headerlink" title="区间选择模型："></a>区间选择模型：</h4><p>给定 $[1, m]$ 中的 $n$ 个区间 $[l_i, r_i]$，每个区间选择一次的代价为 $w_i$，最多可以选 $c_i$ 次，要求使得任意点 $j$ 被覆盖次数在 $[a_j, b_j]$ 之间，求最小 &#x2F; 最大代价。</p><p>将 $1$ 到 $m + 1$ 连成一条链，尝试用 $i \to i + 1$ 边的流量刻画 $i$ 被覆盖的次数。</p><p>建立 $l_i$ 到 $r_i + 1$ 的一条边称为区间边，如果区间边上流过一条流，就表示选择一次这个区间。</p><p>源流向 $1$，$m + 1$ 流向汇，如果我们确定总流量 $X$ 那么没有流经 $i \to i + 1$ 这条边就是选择了区间，那么如果 $i \to i+ 1$ 的流量为 $X - f_i$ 就表示 $i$ 被覆盖了 $f_i$ 次。</p><p>那么我们有一种比较显然的做法，就是考虑对于每个 $i \to i + 1$ 的边流量设置为 $[X - b_i, X - a_i]$，之后将区间费用设为区间代价，容量设为可选次数，对于 $i \to i + 1$ 的边费用为 $0$。</p><p>使用最小 &#x2F; 最大费用上下界最大流即为答案。</p><p>这里 $X$ 可以选择一个充分大的数 $&gt; \max b_i$。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3358">P3358 最长 $k$ 可重区间集问题</a></p><p>从给定的 $m$ 个开区间中选择尽量多的区间，使得每个位置被不超过 $k$ 个区间覆盖，且区间长度和最大。</p></blockquote><p>$w &#x3D; 1, c &#x3D; 1, a &#x3D; 0, b &#x3D; k$。</p><p>由于所有 $b_j$ 相等，所以可以没有下界，能直接普通费用流。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P6967">P6967 [NEERC2016]Delight for a Cat</a></p><p>在 $n$ 个小时中的每个小时，猫可以选择吃饭或睡觉，每个小时吃饭或睡觉有一个愉悦毒，但要求任意连续 $k$ 小时中至少有 $m_e$ 小时吃饭，至少 $m_s$ 小时睡觉，问最大总愉悦度。</p></blockquote><p>可以考虑每个小时都睡觉之后进行决策哪些时间吃饭。</p><p>所以连续 $k$ 小时吃饭的时间在 $[m_e, k - m_s]$ 之间。</p><p>考虑将第 $i$ 小时吃饭的贡献，其可以对于区间右端点在 $[i, i + k - 1]$ 的区间造成贡献，那么对于每个点就有一个覆盖限制。</p><p>$c &#x3D; s_i, w &#x3D;0, a &#x3D; m_e, b &#x3D; k - m_s$，同上题可以跑费用流。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3980">P3980 [NOI2008] 志愿者招募</a></p><p>有 $m$ 个可选操作，每个操作为将 $s_i$ 到 $t_i$ 中每个位置 $+ 1$，代价为 $c_i$，每个操作可以做无限次，要求最后位置 $i$ 上的数不小于 $a_i$，求最小代价。</p></blockquote><p>也就是对于位置 $i$ 的数要 $\ge a_i$。</p><p>模型中的 $w &#x3D; c_i, c &#x3D; +\infty, b &#x3D; +\infty$ 让 $X &#x3D; b$ 就没有下界了。</p><blockquote><p>不要担心设 $\tt inf$。</p></blockquote><h4 id="费用流的凸性"><a href="#费用流的凸性" class="headerlink" title="费用流的凸性"></a>费用流的凸性</h4><p>对于一条边，设其第 $i$ 次流过的代价是 $a_i$，当 $a_i$ 不降时才适合用费用流描述该问题。</p><blockquote><p>每次都是最短路显然。</p></blockquote><p><strong>这一点在模拟费用流时也可以利用，一般来说决策的权值满足凸性的问题可以化为费用流问题，否则一般不行。</strong></p><blockquote><p><a href="https://www.luogu.com.cn/problem/CF436E">CF436E Cardboard Box</a></p><p>有 $n$ 个关卡， 对于第 $i$ 个关卡可以花费 $a_i$ 的代价获得 $1$ 颗星，也可以花费 $b_i$ 的代价获得 $2$ 颗星，求获得 $w$ 颗星的最小代价。</p><p>$O(n \log n)$</p></blockquote><p>返回贪心。。。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4249">P4249 [WC2007]剪刀石头布</a></p><p>给一张已经部分定向的竞赛图定向，使得三元环最多。</p></blockquote><p>考虑三元环不好计算考虑计算非三元环，也就是对于每个非三元环肯定有一个点的出度为 $2$，这可以唯一确定一个非三元环。</p><p>所以非三元环的个数就是 $\sum_i \binom{deg_i}{2}$。</p><p>考虑我们现在就是在钦定边的顺序，对于边 $(i, j)$ 就是决策哪边度数 $+1$。</p><p>考虑 $\binom{a}{b}$ 是不好计算的，所以考虑差分。</p><p>不妨考虑点 $j$ 已经定向了 $d_i$ 的出度，我们考虑新增的出度 $x$ 对于 $x \to x + 1$ 费用为 $\binom{d_i + x}{2} - \binom{d_i + x - 1}{2}$。</p><p>每个点向 $T$ 点连接若干条边，这个表示反悔贪心，因为这个贡献是有凸性的所以是满足费用流的。</p><h4 id="图覆盖模型"><a href="#图覆盖模型" class="headerlink" title="图覆盖模型"></a>图覆盖模型</h4><p>给出一些条件，要求用一些链或圈覆盖图的所有点。</p><p>通常使用二分图模型来描述这类问题：</p><ul><li>$\tt DAG$ 不相交路径覆盖，差点建立二分图，如果右边 $x\to y$ 则从左部点 $x$ 向右部点 $y$ 连边，一个匹配就对应一个不相交路径覆盖，其中匹配边 $x \to y$ 表示 $x, y$ 是一条路径上的前驱后继关系。</li></ul><p>为什么只能做 $\tt DAG$？因为若不是 $\tt DAG$ 这里就会成环，就不是不相交路径覆盖了。</p><ul><li>最少路径的不相交路径覆盖：和最大匹配对应。</li></ul><blockquote><p>或者可以使用 $\tt dilworth$ 定理理解。</p></blockquote><ul><li>最大权不相交路径匹配：等价于最大权二分图匹配的权值。</li><li>$\tt DAG$ 可相交路径覆盖：先传递闭包之后是等价的。</li><li>不相交圈覆盖：给定一张任意有向图，一样建立二分图，每一组完美匹配就对应一个圈覆盖，左部点 $i$ 的匹配点就是其圈上的后继。</li><li>最小 &#x2F; 大权不相交圈覆盖：拆点二分图求最小 &#x2F; 大权二分图匹配。</li></ul><blockquote><p><a href="https://www.luogu.com.cn/problem/P6061">P6061 [加油武汉]疫情调查</a></p><p>给定有向带权图，每次你可以选择一个非空回路，付出其权值和的代价以覆盖其中一个子集，也可以选择一个点 $u$ 付出 $a_u$ 的代价覆盖这个点，求覆盖所有点的最小总代价。</p></blockquote><p>考虑走环中的边 $(i, j)$ 的最小代价是 $d(i, j)$ 直接使用 $\tt floyd$ 即可，直接使用 $\tt KM$ 即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4542">P4542 [ZJOI2011]营救皮卡丘</a></p><p>有 $n + 1$ 个点（$0$ 到 $n$ 编号）的有向带权图，$k$ 个人从 $0$ 出发，每个人每次只能走到编号不超过之前走到过的最大编号 $+ 1$ 的点，每个点要至少被一个人走过，问最小的所有人走过的边边权之和。</p></blockquote><p>首先根据这个限制可以得到如果当前走过的最大的是位置 $i$ 说明 $0 \sim i$ 都已经被遍历过一次了。</p><p>可以考虑设 $d(i, j)$ 表示从 $i$ 经过不超过 $j$ 的点到达 $i$ 的最短路，这个东西本质就是传递闭包了。</p><p>那么每个点至少被一个人走过可以直接跑费用流。</p><h4 id="上下界网络流建图"><a href="#上下界网络流建图" class="headerlink" title="上下界网络流建图"></a>上下界网络流建图</h4><p>当一道题限定了一个点或一条边的流量时，使用上下界网络流解决问题。</p><p>如果一个点不满足流量守恒，可以使用类似上下界网络流的处理手法，建立超级源汇解决问题。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4553">P4553 80人环游世界</a></p><p>用 $m$ 条路径覆盖一个 $\tt DAG$，第 $i$ 个点恰好经过 $v_i$ 次，每条边都有边权，求总边权最小。</p></blockquote><p>每个点拆点限制流量，拆点二分图跑最小费用最大流。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/CF708D">CF708D Incorrect Flow</a></p><p>给定一张网络图和其流函数，不一定满足 $f(u, v) \le c(u, v)$ 和流量守恒，每次操作可以增大或减少一个 $f(u, v)$ 或 $c(u, v)$，求最小操作次数，使得流函数合法。</p></blockquote><ul><li>$f(u, v) \le c(u, v)$</li></ul><p>可以直接对于 $f$ 进行增大 $(u, v, c(u, v) - f(u, v), 1)$。</p><p>可以考虑退流 $(v, u, f(u, v), 1)$。</p><p>可以考虑满流之后增大 $(v, u, +\infty, 2)$。</p><ul><li>$f(u, v) &gt; c(u, v)$</li></ul><p>先需要计算修正代价，预先加上 $c(u, v) - f(u, v)$。</p><p>增广正向边 $(u, v, +\infty, 2)$。</p><p>退流不小于 $c(u, v)$，反向边 $(u, v, f(u, v) - c(u, v), 0)$。</p><p>退流小于 $c(u, v)$，反向边，容量为 $c(u, v)$ 费用为 $1$。</p><p>如何保证流量守恒，很显然总共的流在原来的地方是不变的，所以我们考虑计算出每个点流入和流出的差值，然后像上下界网络流一样建边即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P4003">P4003 无限之环</a></p><p>题面复杂。</p></blockquote><p><a href="https://legendgod.ml/2022/04/14/lg-solution-p4003/">Legendgod’s Blog 题解</a></p><blockquote><p><a href="https://www.luogu.com.cn/problem/P3296">[SDOI 2013] 刺客信条</a></p><p>给定一棵 $n$ 个点的无根数和一个长度为 $n$ 的 $01$ 串，以及一个长度为 $n$ 的目标 $01$串，每次操作可以翻转当前 $01$ 串的一位，最终要使得存在一种数的自同构排列，使得排列后当前 $01$ 串变成目标串。</p></blockquote><p><a href="https://legendgod.ml/2022/04/14/lg-solution-p3296/">Legendgod’s Blog 题解</a></p><p>下面就是比较通用的思路了。</p><h4 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h4><blockquote><p><a href="https://www.luogu.com.cn/problem/P2065">P2065 [TJOI2011]卡片</a></p><p>有一个二分图，左右分别 $n, m$ 个点，一个左部点和一个右部点有边当且仅当点权不互质，求最大匹配。</p><p>$n, m \le 500$</p></blockquote><p>考虑点权不互质就是至少有一个公因子，考虑中间放一个公因子之后来连接两边这样，这样边数就会变成 $O((n + m) \omega(V))$。</p><p>之后跑网络流即可。</p><blockquote><p><a href="https://www.luogu.com.cn/problem/P5331">P5331 [SNOI2019]通信</a></p><p>给 $n$ 个点排成一列，对于权值为 $a_i$ 的 $i$ 点或者选择支付 $w$ 的代价，或者选择一个 $j &lt;i$ 然后支付 $|a_i - a_j|$ 的代价，对于每个 $j$ 只能被选择一次，求最小代价和。</p></blockquote><p>先考虑朴素的网络流，考虑当前是否被选择了。</p><ul><li>$s \to i \to t$ 表示直接连接。</li><li>$s \to i \to j’ \to t$ 表示间接连接，限制 $j’ \to t$ 的流量。</li></ul><p>这样边数是 $O(n^2)$ 的。</p><p>发现连接肯定是一个前缀考虑建立虚点来连接，考虑费用怎么计算。</p><p>考虑将权值排序之后相互连接，之后将每个点连接到对应权值的点上。</p><p>这样边数就是 $O(n \log n)$ 级别的了。</p><h4 id="拆贡献"><a href="#拆贡献" class="headerlink" title="拆贡献"></a>拆贡献</h4><blockquote><p><a href="https://www.luogu.com.cn/problem/P2050">P2050 [NOI2012] 美食节</a></p><p>有 $n$ 种菜和 $m$ 个厨师，第 $i$ 个厨师做<strong>一道</strong>第 $j$ 种菜时间为 $t_{i, j}$，第 $i$ 种菜有 $p_i$ 个同学想要，每个厨师同时只能做一道菜，问所有同学的最小等待时间和。</p></blockquote><p>首先可以考虑每个厨师做第 $i$ 道菜的贡献，考虑让 $S$ 连接所有的菜，之后考虑厨师做第 $i$ 个菜的贡献，显然这个贡献是有凸性的，因为边数过多所以我们可以考虑对于每次做了菜的厨师再增加其做下一道菜的费用的边。这样点数就被控制在 $\sum p_i$ 中了。</p><blockquote><p>注意这样是不能使用 $\tt dijsktra$ 的。</p></blockquote><blockquote><p><a href="https://www.luogu.com.cn/problem/P2570">P2570 [ZJOI2010]贪吃的老鼠</a></p><p>有 $n$ 个奶酪和 $m$ 个老鼠，第 $i$ 个奶酪大小 $p_i$，第 $i$ 个老鼠吃奶酪的速度是 $v_i$，同一时刻一个老鼠只能吃一个奶酪，一个奶酪只能被一个老鼠吃，每个奶酪有出现的时间区间 $[l_i, r_i]$，现在可以将所有 $r_i$ 都增加一个量，求最少要增加多少可以使得所有奶酪都被吃完。</p></blockquote><p>二分答案转成判定性问题。</p><p>我们先思考最朴素的建图，源点向奶酪连边，容量为奶酪大小，之后将老鼠按照离散化后的时间段拆点，每个时间段向对应的可以吃的奶酪连边，容量为老鼠的 $v \times tim$。</p><blockquote><p>考虑还有什么条件是不满足的，可能会出现一块奶酪同一时刻被多只老鼠吃，显然可能存在奶酪大小为 $p_i$ 有 $\max v \times tim &lt; p_i$ 但是在该时段流满的情况。</p></blockquote><p>那么我们需要限制每个时段对于每个奶酪的流，按照老鼠的速度排序，不妨考虑当前时刻第一个吃当前奶酪的老鼠为 $i$ 显然我们需要限制 $\forall j, j &gt; i$ 的老鼠不吃，考虑每个时刻只能使用一个 $v$，但是我们不能表示该限制我们只能表示一段区间的 $v$ 同时被使用了，考虑将 $v$ 表示成前缀的形式也就是差分。</p><p>考虑一种神奇的建图：</p><ul><li>首先将老鼠吃的速度排序之后差分，设第 $i$ 只老鼠的速度为 $\sum_{j &#x3D; 1} ^ iu_j$。</li><li>在每个时间段对于每个 $u_i$ 建点，与每个奶酪连权值为 $u_i \times tim$ 容量的边（$tim$ 是时间长度），这样可以保证一个奶酪的出边不会超过老鼠的限制。</li><li>每个 $u_i$ 对应的点向汇点连 $u_i\times (m-i+1)\times tim$ 容量的边，相当于限制了每个值域前缀的总消耗量。</li></ul><hr><p>目前图论二分图和网络流部分就已经学完了，还少一块模拟费用流之后会补上的。</p><p>正好 $20000$ 字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;据说图论我会的东西相对少一点，我们先写图论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二分图概念和判定&quot;&gt;&lt;a href=&quot;#二分图概念和判定&quot; class=&quot;headerlink&quot; title=&quot;二分图概念和判定&quot;&gt;&lt;/a&gt;二分图概念</summary>
      
    
    
    
    <category term="算法" scheme="https://legendgod.ml/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="分块" scheme="https://legendgod.ml/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>P3296 [SDOI2013]刺客信条 / assassin 题解</title>
    <link href="https://legendgod.ml/2022/04/14/lg-solution-p3296/"/>
    <id>https://legendgod.ml/2022/04/14/lg-solution-p3296/</id>
    <published>2022-04-14T06:32:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3296">P3296 [SDOI2013]刺客信条</a></p><p><strong>题目简化</strong>：</p><p>给定一棵树，每个点有两个 $0, 1$ 权值，合适地安排节点在同构树中的顺序，使得前后对应的权值不同节点个数最小，并输出。</p><p>本质上就是对于同构树来考虑每棵子树如何配对的问题，所以先找到中重心之后使用树 $\tt Hash$ 判断出同构。</p><p>对于同构的两棵树考虑分成若干组子树，每组子树都是同构的，对于每组子树我们事实上可以任意匹配，需要选择出最优解保证每棵子树都有匹配且边权最小。这个本质就是最小权二分图匹配，直接使用 $\tt KM$ 即可。</p><p>复杂度是 $O(n^3)$ 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="comment">//#define Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">700</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SKM &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int64;</span><br><span class="line">    <span class="keyword">int</span> n, w[maxn][maxn];</span><br><span class="line">    <span class="keyword">const</span> int64 inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="keyword">int</span> mt[maxn], pre[maxn];</span><br><span class="line">    int64 ex[maxn], ey[maxn], sl[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">yy</span>(<span class="number">0</span>), i; int64 tmp;</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) sl[i] = inf;</span><br><span class="line">        mt[y] = u;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            x = mt[y], tmp = inf, vis[y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(sl[i] &gt; ex[x] + ey[i] - w[x][i]) &#123;</span><br><span class="line">                    sl[i] = ex[x] + ey[i] - w[x][i];</span><br><span class="line">                    pre[i] = y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sl[i] &lt; tmp) tmp = sl[i], yy = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[i]) ex[mt[i]] -= tmp, ey[i] += tmp;</span><br><span class="line">                <span class="keyword">else</span> sl[i] -= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            y = yy;</span><br><span class="line">            <span class="keyword">if</span>(mt[y] == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y) mt[y] = mt[pre[y]], y = pre[y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ex, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ex));</span><br><span class="line">        <span class="built_in">memset</span>(ey, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ey));</span><br><span class="line">        <span class="built_in">memset</span>(mt, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">            <span class="built_in">bfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">int64 <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span>(mt[i] != <span class="number">-1</span>)</span><br><span class="line">            res += w[mt[i]][i];</span><br><span class="line">        <span class="keyword">return</span> - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], <span class="built_in">cnt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edg[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edg[++ cnt] = (Edge) &#123;v, head[u]&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c1[maxn][maxn], c2[maxn][maxn], H[maxn], siz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Tmp</span><span class="params">(<span class="number">1e9</span>)</span>, root</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, base = <span class="number">13331</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdrt</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    siz[p] = <span class="number">1</span>; <span class="function"><span class="keyword">int</span> <span class="title">mx</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[p];i;i = edg[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = edg[i].to; <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fdrt</span>(to, p);</span><br><span class="line">        siz[p] += siz[to];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, siz[to]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx = <span class="built_in">max</span>(mx, n - siz[p]);</span><br><span class="line">    <span class="keyword">if</span>(mx &lt; Tmp) root = p, Tmp = mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> pre,<span class="keyword">int</span> sn[][maxn])</span> </span>&#123;</span><br><span class="line">    H[p] = <span class="number">5201314046ll</span> % mod;</span><br><span class="line">    <span class="built_in">memset</span>(sn[p], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sn[p]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[p];i;i = edg[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = edg[i].to; <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(to, p, sn);</span><br><span class="line">        sn[p][++ sn[p][<span class="number">0</span>]] = to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sn[p] + <span class="number">1</span>, sn[p] + sn[p][<span class="number">0</span>] + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x, <span class="keyword">const</span> <span class="keyword">int</span>&amp; y) &#123; <span class="keyword">return</span> H[x] &lt; H[y]; &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sn[p][<span class="number">0</span>]; ++ i) H[p] = ( (<span class="number">1ll</span> * base * H[p]) ^ H[sn[p][i]] ) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sa[maxn], s[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">// the mincost we need to change tree x to y</span></span><br><span class="line">    <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">int</span>&amp; res = f[x][y]; res = s[x] ^ sa[y];</span><br><span class="line">    <span class="keyword">int</span> num = c1[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= num &amp;&amp; H[c1[x][j + <span class="number">1</span>]] == H[c1[x][i]]) ++ j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++ k) <span class="keyword">for</span>(<span class="keyword">int</span> z = i; z &lt;= j; ++ z) <span class="built_in">Solve</span>(c1[x][k], c2[y][z]), <span class="built_in"><span class="keyword">void</span></span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++ k) <span class="keyword">for</span>(<span class="keyword">int</span> z = i; z &lt;= j; ++ z) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">Solve</span>(c1[x][k], c2[y][z]);</span><br><span class="line">            SKM::w[k - i + <span class="number">1</span>][z - i + <span class="number">1</span>] = - tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        SKM::n = j - i + <span class="number">1</span>;</span><br><span class="line">        res += SKM::<span class="built_in">KM</span>();</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;2.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//    freopen(&quot;q2.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">r1</span>(u, v), <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(s[i]);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">r1</span>(sa[i]);</span><br><span class="line">    <span class="built_in">fdrt</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>, c2);</span><br><span class="line">    <span class="keyword">int</span> tmp = H[root], <span class="built_in">ans</span>(<span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, <span class="number">0</span>, c1);</span><br><span class="line">        <span class="keyword">if</span>(H[i] == tmp) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="built_in">Solve</span>(i, root));</span><br><span class="line"><span class="comment">//            printf(&quot;i = %d\n&quot;, i);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3296&quot;&gt;P3296 [SDOI2013]刺客信条&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目简化&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;给定一棵树，每个点有两个 $0, 1$ 权值，合适地</summary>
      
    
    
    
    <category term="洛谷题解" scheme="https://legendgod.ml/categories/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="图论" scheme="https://legendgod.ml/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="Dp" scheme="https://legendgod.ml/tags/Dp/"/>
    
    <category term="二分图" scheme="https://legendgod.ml/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>P4003 无限之环 题解</title>
    <link href="https://legendgod.ml/2022/04/14/lg-solution-p4003/"/>
    <id>https://legendgod.ml/2022/04/14/lg-solution-p4003/</id>
    <published>2022-04-14T00:48:00.000Z</published>
    <updated>2022-11-11T11:18:54.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4003">P4003 无限之环</a></p><p>如果直接来做其实一点头绪都没有，于是我们可以点开 <a href="https://poki.com/en/g/infinity-loop">Infinity Loop</a></p><p>玩了一会。</p><p>玩的过程中发现一个明显的性质不管最终答案是什么样的，每个插头都是被另外一个插头配对的。</p><p>那么本质上就是每个格子的 $4$ 个位置有若干个是插头，每个插头需要被配对，每次旋转需要代价，求最小代价使得所有插头被配对。</p><p>显然对于一个插头我们被配对当且仅当其和 $1$ 个另外的插头配对。</p><p>我们考虑拆点限制这个 $1$，考虑使用费用流。</p><p>我们可以考虑对于每个格子拆成 $5$ 个点，一个点来限制其他点的 $1$ 次流量，然后剩下 $4$ 个点表示插头，因为需要有源点和汇点我们不妨仿照<a href="https://www.luogu.com.cn/problem/P3355">骑士共存问题</a>进行染色。</p><p>考虑旋转是怎么表示的，本质上就是看这个 $1$ 的流流到哪里去，就是简单连边。</p><ul><li>一个插头，相邻位置费用为 $1$，对面为 $2$。</li><li>$\tt L$ 形插头，考虑最上面的位置顺时针旋转 $1$ 次可以使最下面插头合法，所以是对面连边费用为 $1$。费用为 $2$ 的情况可以不考虑，因为本质上就是两次费用为 $1$ 的旋转。</li><li>三个插头，可以通过一次相邻旋转或者一次相对旋转，费用为 $1, 2$。</li></ul><p>之后直接使用费用流即可，代码很好写。</p><blockquote><p>其实我写法常数可以不用那么大的，但是他短而且不用讨论呀！</p><p>费用流使用了顶标费用流，其中 $\tt dijsktra$ 使用了配对堆优化，复杂度卡得比较满，但是对于图层数比较少的情况可以使用 $\tt dinic$ 快速增广。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/extc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Legendgod &#123;</span><br><span class="line"><span class="keyword">namespace</span> Read &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Fread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Fread</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Siz = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> *iS, *iT, buf[Siz];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() ( iS == iT ? (iT = (iS = buf) + fread(buf, 1, Siz, stdin), iS == iT ? EOF : *iS ++) : *iS ++ )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar gc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">c</span><span class="params">(getchar())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>);</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>...Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">r1</span><span class="params">(T &amp;x, Args&amp;...arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">r1</span>(x), <span class="built_in">r1</span>(arg...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> getchar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Read;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">2e3</span>) * <span class="number">5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, S, T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">    <span class="keyword">int</span> w, c;</span><br><span class="line">&#125;edg[maxn * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], <span class="built_in">cnt</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edg[++ cnt] = (Edge) &#123;v, head[u], w, c&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add1</span>(u, v, w, c), <span class="built_in">add1</span>(v, u, <span class="number">0</span>, -c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[maxn], dis[maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="number">4</span> * (T + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">static</span> queue&lt;<span class="keyword">int</span>&gt; q; <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    h[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//        printf(&quot;u = %d\n&quot;, u);</span></span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = edg[i].next) <span class="keyword">if</span>(edg[i].w) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edg[i].to;</span><br><span class="line">            <span class="keyword">if</span>(h[to] &gt; h[u] + edg[i].c) &#123;</span><br><span class="line">                h[to] = h[u] + edg[i].c;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to]) vis[to] = <span class="number">1</span>, q.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, dis;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;z) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; z.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dij</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="number">4</span> * (T + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="number">4</span> * (T + <span class="number">2</span>));</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> __gnu_pbds::priority_queue&lt;Node&gt; q; <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">top</span>().id; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = edg[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edg[i].to; <span class="keyword">int</span> w = edg[i].w, c = edg[i].c;</span><br><span class="line">            <span class="keyword">if</span>(w &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = dis[u] + h[u] - h[to] + c;</span><br><span class="line">            <span class="keyword">if</span>(dis[to] &gt; tmp) &#123;</span><br><span class="line">                dis[to] = tmp;</span><br><span class="line">                pre[to] = i;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;to, dis[to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf(&quot;T = %d\n&quot;, dis[T]);</span></span><br><span class="line">    <span class="keyword">return</span> dis[T] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//    puts(&quot;SSs&quot;);</span></span><br><span class="line">    <span class="built_in">Spfa</span>();</span><br><span class="line"><span class="comment">//    puts(&quot;SSs&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Dij</span>()) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ansf</span><span class="params">(inf)</span>, <span class="title">ansc</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i != S; i = edg[pre[i] ^ <span class="number">1</span>].to)</span><br><span class="line">            ansf = <span class="built_in">min</span>(ansf, edg[pre[i]].w);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T; i != S; i = edg[pre[i] ^ <span class="number">1</span>].to) &#123;</span><br><span class="line">            edg[pre[i]].w -= ansf, edg[pre[i] ^ <span class="number">1</span>].w += ansf;</span><br><span class="line">            ansc += ansf * edg[pre[i]].c;</span><br><span class="line">        &#125;</span><br><span class="line">        x += ansf, y += ansc;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++ i) <span class="keyword">if</span>(dis[i] &lt; inf) h[i] += dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mf[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 1 2 3 4</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> Sm, <span class="built_in">sumk</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * m + y + c * Sm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op = (x + y) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(op) &#123;</span><br><span class="line">        <span class="built_in">add</span>(S, <span class="built_in">id</span>(x, y, <span class="number">0</span>), inf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + d[i][<span class="number">0</span>], ny = y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">id</span>(x, y, i + <span class="number">1</span>), <span class="built_in">id</span>(nx, ny, mf[i]), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(<span class="built_in">id</span>(x, y, <span class="number">0</span>), T, inf, <span class="number">0</span>);</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; vadd;</span><br><span class="line">    vadd = [&amp;](<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="built_in">add</span>(u, v, w, c);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(v, u, w, c);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> W = a[x][y], <span class="built_in">ssk</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="keyword">if</span>((W &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        ++ sumk, <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, <span class="number">0</span>), <span class="built_in">id</span>(x, y, i + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ++ ssk;</span><br><span class="line"><span class="comment">//        printf(&quot;(%d, %d)\n&quot;, x, y);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> opsi[<span class="number">4</span>] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span>(ssk == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ps = <span class="number">0</span>; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="keyword">if</span>((W &gt;&gt; i) &amp; <span class="number">1</span>) &#123; ps = i + <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i) <span class="keyword">if</span>(i != ps &amp;&amp; i != opsi[ps - <span class="number">1</span>]) <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, ps), <span class="built_in">id</span>(x, y, i), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, ps), <span class="built_in">id</span>(x, y, opsi[ps - <span class="number">1</span>]), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ssk == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++ i) <span class="keyword">if</span>((W &gt;&gt; i) &amp; <span class="number">1</span>) <span class="keyword">if</span>((W &gt;&gt; (i + <span class="number">2</span>)) &amp; <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="keyword">if</span>((W &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, i + <span class="number">1</span>), <span class="built_in">id</span>(x, y, opsi[i]), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ssk == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">ps</span>(<span class="number">0</span>), nps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="keyword">if</span>(!((W &gt;&gt; i) &amp; <span class="number">1</span>)) &#123; ps = i + <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        nps = opsi[ps - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) <span class="keyword">if</span>((i + <span class="number">1</span> != ps) &amp;&amp; (i + <span class="number">1</span> != nps))</span><br><span class="line">            <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, i + <span class="number">1</span>), <span class="built_in">id</span>(x, y, ps), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vadd</span>(<span class="built_in">id</span>(x, y, nps), <span class="built_in">id</span>(x, y, ps), <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;fdata.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">r1</span>(n, m);</span><br><span class="line">    Sm = n * m;</span><br><span class="line">    S = Sm * <span class="number">5</span> + <span class="number">1</span>, T = S + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">        <span class="built_in">r1</span>(a[i][j]);</span><br><span class="line">        <span class="built_in">build</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">Solve</span>();</span><br><span class="line"><span class="comment">//    printf(&quot;sumk = %d\n&quot;, sumk);</span></span><br><span class="line"><span class="comment">//    printf(&quot;mxflow = (%lld, %lld)\n&quot;, tmp.first, tmp.second);</span></span><br><span class="line">    <span class="keyword">if</span>(tmp.first * <span class="number">2</span> == sumk) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp.second);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Legendgod::<span class="built_in">main</span>(), <span class="number">0</span>; &#125;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4003&quot;&gt;P4003 无限之环&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果直接来做其实一点头绪都没有，于是我们可以点开 &lt;a href=&quot;https://poki.com/en/g/infinity-l</summary>
      
    
    
    
    <category term="洛谷题解" scheme="https://legendgod.ml/categories/%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="图论" scheme="https://legendgod.ml/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="网络流" scheme="https://legendgod.ml/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
</feed>
